<?php
// $Id$

/**
 * @file
 * Manages site templates and features on Gardens sites.
 */

/**
 * Indicates that the feature must always be installed with the site template.
 */
define('SITE_TEMPLATE_FEATURE_REQUIRED', 'required');

/**
 * Indicates that the feature is part of the standard installation for the site
 * template. (This is the default behavior.)
 */
define('SITE_TEMPLATE_FEATURE_STANDARD', 'standard');

/**
 * Indicates that the feature is allowed to be installed with the site
 * template, but is not turned on by default.
 */
define('SITE_TEMPLATE_FEATURE_EXTRA', 'extra');

/**
 * Implements hook_menu().
 */
function site_template_menu() {
  $items = array();
  $items['admin/structure/templates'] = array(
    'title' => 'Site template debug',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('site_template_debug_form'),
    'access arguments' => array('access devel information'),
  );
  return $items;
}

/**
 * Implements hook_site_template_info().
 */
function site_template_site_template_info() {
  // Template for a standard Gardens installation.
  $templates['drupal'] = array(
    'name' => t('Do it yourself'),
    'description' => t("Ideal for Drupal experts. Start from scratch. Build everything yourself. All we've done is enable the most common suite of modules."),
    'features' => array(
      'site_template_sample_article' => array('type' => SITE_TEMPLATE_FEATURE_REQUIRED),
      'site_template_comment_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_comment_notify_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_follow_us_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_share_this_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_about_page' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_blog_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_contact_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_mailing_list_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_forum_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_news_page' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_rotating_banner_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_faq_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_twitter_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_feedback_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_gallery_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      'site_template_webforms_feature' => array('type' => SITE_TEMPLATE_FEATURE_EXTRA),
      // Features that must run at the end, to do things that require, e.g.,
      // all the template's content types to have been created or modules to
      // have been installed.
      'site_template_add_content_manager_role' => array('type' => SITE_TEMPLATE_FEATURE_REQUIRED),
      'site_template_update_node_types' => array('type' => SITE_TEMPLATE_FEATURE_REQUIRED),
    ),
    'editable variables' => array('theme_default'),
  );
  return $templates;
}

/**
 * @defgroup site_template_api API functions for managing site templates.
 * @{
 */

/**
 * Returns an array of site templates, keyed by the template name.
 */
function site_template_get_all_templates() {
  $info = module_invoke_all('site_template_info');

  // Make sure each feature has a type ("standard" features are the default if
  // no type was specified).
  foreach ($info as &$template_info) {
    if (!empty($template_info['features'])) {
      foreach ($template_info['features'] as &$feature) {
        if (!isset($feature['type'])) {
          $feature['type'] = SITE_TEMPLATE_FEATURE_STANDARD;
        }
      }
    }
  }

  return $info;
}

/**
 * Returns the machine-readable name of the current template in use on the site.
 */
function site_template_current_template() {
  return variable_get('site_template_current_template', 'drupal');
}

/**
 * Get a new instance of a class associated with a site template.
 *
 * @param $template
 *   The name of the template.
 *
 * @return
 *   An new instance of the class associated with that template.
 */
function site_template_get_instance($template) {
  $prefix = ucfirst($template);
  $class = "{$prefix}SiteTemplate";
  $instance = new $class;
  return $instance;
}

/**
 * Returns the human-readable name of the provided site template.
 */
function site_template_human_readable_name($template) {
  $templates = site_template_get_all_templates();
  return $templates[$template]['name'];
}

/**
 * Finalize the choice of site templates.
 */
function site_template_finalize_template_selection() {
  // Delete all module variables except 'site_template_current_template' (which
  // preserves a record of the final site template that was chosen).
  variable_del('site_template_saved_variable_states');
  variable_del('site_template_rollback_data');
  variable_del('site_template_extra_rollback_data');
}

/**
 * Install features belonging to a given site template.
 *
 * @param $template
 *   The name of the template.
 * @param $requested_features
 *   (optional) An array of features to be enabled for this site template. If
 *   provided, only these features (plus any other features specifically
 *   required by the template) will be enabled. If not provided, all features
 *   defined by the template will be enabled.
 */
function site_template_install_features($template, $requested_features = NULL) {
  $templates = site_template_get_all_templates();

  // If no features were explicitly requested, we use all the normal ones that
  // this template provides (everything that is not an "extra" feature).
  if (!isset($requested_features)) {
    $requested_features = !empty($templates[$template]['features']) ? $templates[$template]['features'] : array();
    foreach ($requested_features as $name => $feature) {
      if ($feature['type'] == SITE_TEMPLATE_FEATURE_EXTRA) {
        unset($requested_features[$name]);
      }
    }
  }
  else {
    $requested_features = array_flip($requested_features);
  }

  // Go through each feature and include it if it was requested or if it is
  // required. Note that this method guarantees the features will be installed
  // in the order the template defines them (rather than the order which they
  // are passed in to this function), which is what we want.
  $features = array();
  if (!empty($templates[$template]['features'])) {
    foreach ($templates[$template]['features'] as $feature => $info) {
      if (isset($requested_features[$feature]) || $info['type'] == SITE_TEMPLATE_FEATURE_REQUIRED) {
        $features[] = $feature;
        unset($requested_features[$feature]);
      }
    }
  }

  // Warn about any requested features that the template didn't list; these
  // will not be installed.
  if (!empty($requested_features)) {
    foreach (array_keys($requested_features) as $feature) {
      watchdog('site_template', 'The @feature feature could not be installed because the @template template does not include it in its list of allowed features.', array('@feature' => $feature, '@template' => $template), WATCHDOG_ERROR);
    }
  }

  // Initialize an instance of the template class.
  $template_instance = site_template_get_instance($template);

  // Execute the callback function for each feature, and store any data needed
  // to roll the feature back.
  $rollback_data = variable_get('site_template_rollback_data', array());
  $rollback_data[$template] = array();
  foreach ($features as $feature) {
    $install_callback = "{$feature}_install";
    if (is_callable(array($template_instance, $install_callback))) {
      $rollback_data[$template][$feature] = array();
      $prepare_callback = "{$feature}_install_prepare";
      if (is_callable(array($template_instance, $prepare_callback))) {
        $template_instance->{$prepare_callback}($rollback_data[$template][$feature], $features);
      }
      $template_instance->{$install_callback}($rollback_data[$template][$feature], $features);
    }
    else {
      watchdog('site_template', 'The @feature feature could not be installed because the function it corresponds to does not exist in the @template template.', array('@feature' => $feature, '@template' => $template), WATCHDOG_ERROR);
    }
  }

// TODO: Removed this for now to save time, since the $rollback_data array is
// large and we aren't using it now anyway. Add it back when we start allowing
// features/templates to be installed/uninstalled after the initial site
// creation.
/**
  // Add additional rollback data that allows us to properly deal with
  // variables that we are going to allow people to edit while this template is
  // being sampled.
  $extra_rollback_data = variable_get('site_template_extra_rollback_data', array());
  // First make sure we save the current status of these variables (at the end
  // of the template installation), so we will be able to roll back to that
  // state.
  $extra_rollback_data[$template] = array(site_template_get_variable_states($templates[$template]['editable variables']));
  // Next, if the user edited any of these variables the last time they used
  // this template, restore them to that value here, and save that status so it
  // can be rolled back as well.
  $previous_saved_variable_states = variable_get('site_template_saved_variable_states', array());
  if (isset($previous_saved_variable_states[$template])) {
    site_template_restore_variables_from_state($previous_saved_variable_states[$template]);
    $extra_rollback_data[$template][] = site_template_get_variable_states(array_keys($previous_saved_variable_states[$template]));
    // Remove the previous saved variable states for this template, since we do
    // not need them anymore.
    unset($previous_saved_variable_states[$template]);
    variable_set('site_template_saved_variable_states', $previous_saved_variable_states);
  }

  // Reverse the order of the features before saving the rollback data, so that
  // we roll back the features in the opposite order they were saved in.
  $rollback_data[$template] = array_reverse($rollback_data[$template]);
  $extra_rollback_data[$template] = array_reverse($extra_rollback_data[$template]);
  variable_set('site_template_rollback_data', $rollback_data);
  variable_set('site_template_extra_rollback_data', $extra_rollback_data);
**/

  // Store the name of the template that was installed.
  variable_set('site_template_current_template', $template);

  // Because we may have enabled modules while installing site features, we
  // need to clear caches.
  drupal_flush_all_caches();
}

/**
 * Uninstall features belonging to a given site template.
 *
 * @param $template
 *   The name of a site template. All the features that were previously
 *   installed for it will be uninstalled, in the reverse order in which they
 *   were installed.
 */
function site_template_uninstall_features($template) {
  // Before uninstalling the template, first save any variables that the user
  // was allowed to edit while they were using it. These will be used if the
  // template is later reinstalled.
  $templates = site_template_get_all_templates();
  $current_saved_variable_states = variable_get('site_template_saved_variable_states', array());
  $current_saved_variable_states[$template] = site_template_get_variable_states($templates[$template]['editable variables']);
  variable_set('site_template_saved_variable_states', $current_saved_variable_states);

  // Next, roll back any special data associated with these variables.
  $extra_rollback_data = variable_get('site_template_extra_rollback_data', array());
  if (isset($extra_rollback_data[$template])) {
    foreach ($extra_rollback_data[$template] as $variable_states) {
      site_template_restore_variables_from_state($variable_states);
    }
  }

  // Initialize an instance of the template class.
  $template_instance = site_template_get_instance($template);

  // Finally, roll back the normal template features.
  $rollback_data = variable_get('site_template_rollback_data', array());
  if (isset($rollback_data[$template])) {
    foreach ($rollback_data[$template] as $feature => $rollback_arguments) {
      $rollback_callback = "{$feature}_rollback";
      if (is_callable(array($template_instance, $rollback_callback))) {
        $rollback_prepare_callback = "{$feature}_rollback_prepare";
        if (is_callable(array($template_instance, $rollback_prepare_callback))) {
          $template_instance->{$rollback_prepare_callback}($rollback_arguments);
        }
        $template_instance->{$rollback_callback}($rollback_arguments);
      }
    }
  }
}

/**
 * @} End of "defgroup site_template_api".
 */

/**
 * @defgroup site_template_features_api API used by site template features.
 * @{
 */

/**
 * Given a list of variables, returns an array representing their current state.
 *
 * @param $variable_names
 *   An array containing variable names.
 *
 * @return
 *   An associative array whose keys are variable names and whose values are
 *   either an empty array (if the variable in question is not currently
 *   defined) or an array with a single key 'value' set to the current stored
 *   value for that variable.
 */
function site_template_get_variable_states($variable_names) {
  global $conf;
  $variable_states = array();
  foreach ($variable_names as $name) {
    // Use array_key_exists() here to properly handle variables that are set to
    // NULL.
    if (array_key_exists($name, $conf)) {
      $variable_states[$name]['value'] = $conf[$name];
    }
    else {
      $variable_states[$name] = array();
    }
  }
  return $variable_states;
}

/**
 * Restore a list of variables to the state that is passed in.
 *
 * @param $variable_states
 *   An array of the form returned by site_template_get_variable_states().
 *   Each variable in this list will be restored to its previous stored state.
 *
 * @see site_template_get_variable_states()
 */
function site_template_restore_variables_from_state($variable_states) {
  foreach ($variable_states as $name => $state) {
    // Use array_key_exists() here to properly handle variables that are set to
    // NULL.
    if (array_key_exists('value', $state)) {
      variable_set($name, $state['value']);
    }
    else {
      variable_del($name);
    }
  }
}

/**
 * Given a list of permissions, returns an array representing their current state.
 *
 * @param $permission_names
 *   An array containing permission names.
 *
 * @return
 *   An associative array whose keys are permission names and whose values are
 *   themselves an array, with each role ID as key, and FALSE as the value if
 *   the role does not have the permission or TRUE as the value if it does.
 *
 * @see site_template_restore_permissions_from_state()
 */
function site_template_get_permission_states($permission_names) {
  $permission_states = array();
  $roles = array_keys(user_roles());
  foreach ($permission_names as $permission) {
    $permission_roles = array_keys(user_roles(FALSE, $permission));
    foreach ($roles as $role) {
      $permission_states[$permission][$role] = in_array($role, $permission_roles);
    }
  }
  return $permission_states;
}

/**
 * Restore a list of permissions to the state that is passed in.
 *
 * @param $variable_states
 *   An array of the form returned by site_template_get_permission_states().
 *   Each permission in this list will be restored to its previous stored state.
 *
 * @see site_template_get_permission_states()
 */
function site_template_restore_permissions_from_state($permission_states) {
  foreach ($permission_states as $permission => $role_states) {
    foreach ($role_states as $role => $state) {
      user_role_change_permissions($role, array($permission => $state));
    }
  }
}

/**
 * Get a site owner uid for content.
 */
function site_template_get_uid() {
  $owner_uids = scarecrow_list_site_owner_uids();
  $uid = end($owner_uids);
  return $uid;
}

/**
 * Returns an array of Gardens prefooter regions, ordered left to right.
 *
 * Useful for passing in to site_template_enable_block() in the 'region' key,
 * since this will trigger it to put the block in the first available prefooter
 * region.
 */
function site_template_prefooter_regions() {
  return array(
    'prefooter_first',
    'prefooter_second',
    'prefooter_third',
  );
}

/**
 * Adds a basic node to the site, good old-D6 style.
 *
 * @param $data
 *   An array of data about the node, with the following keys:
 *   - title: The title of the node. Also used for a menu link when applicable
 *     (when 'menu_link' is set below but its 'link_title' key is not).
 *   - body: The text of the node body.
 *   - fields: (Optional) An array of field API definitions for field data to
 *     save with the node.
 *   - format: (Optional) The text format of the node body. Defaults to using
 *     the Gardens Safe HTML format.
 *   - type: (Optional) The node type. Defaults to 'page'.
 *   - promote: (Optional) Set to NODE_PROMOTED or NODE_NOT_PROMOTED to force a
 *     certain behavior.
 *   - uid: (Optional) The ID of the user who will be the owner of the node.
 *     Defaults to a Gardens site owner uid.
 *   - alias: (Optional) A URL alias for the node.
 *   - comment: (Optional) Comment settings for the node. If not set, the
 *     default setting for that content type is used.
 *   - menu_link: (Optional) An array to be used as $node->menu; i.e., for
 *     menu_link_save(). The 'link_title' key will default to the node title
 *     (provided above) if not set. The 'menu_name' key must be set.
 * @return
 *   An object representing the node that was created.
 */
function site_template_add_basic_node($data) {
  // Since we are often creating nodes in rapid-fire succession, they would
  // sometimes get the same timestamp by default (which could mess up their
  // order in node listings). Here, we always make sure that the timestamps
  // match the order in which they were created.
  $created_time = &drupal_static(__FUNCTION__);
  if (empty($created_time)) {
    $created_time = REQUEST_TIME;
  }
  else {
    // Use the correct time if we can; otherwise, increment by one second.
    $time = REQUEST_TIME;
    if ($time > $created_time) {
      $created_time = $time;
    }
    else {
      $created_time += 1;
    }
  }

  $node = new stdClass();
  $node->created = $created_time;
  $node->type = isset($data['type']) ? $data['type'] : 'page';
  $node->title = $data['title'];

  if (!empty($data['body'])) {
    $format = !empty($data['format']) ? $data['format'] : variable_get('gardens_safe_html_format');
    $node->body = array(LANGUAGE_NONE => array(array(
      'summary' => '',
      'value' => $data['body'],
      'format' => $format,
      'value_format' => $format,
    )));
  }

  $node->uid = isset($data['uid']) ? $data['uid'] : site_template_get_uid();
  $node->language = LANGUAGE_NONE;
  $node->status = NODE_PUBLISHED;

  if (isset($data['promote'])) {
    $node->promote = $data['promote'];
  }

  if (isset($data['alias'])) {
    $node->path = array(
      'alias' => $data['alias'],
      'pathauto_perform_alias' => FALSE,
    );
  }

  $node->comment = isset($data['comment']) ? $data['comment'] : variable_get("comment_{$node->type}", COMMENT_NODE_OPEN);

  if (isset($data['menu_link']['menu_name'])) {
    $node->menu = array(
      'link_title' => isset($data['menu_link']['link_title']) ? $data['menu_link']['link_title'] : $data['title'],
      'menu_name' => $data['menu_link']['menu_name'],
      'enabled' => TRUE,
      // Put the item last in the menu by default.
      'weight' => isset($data['menu_link']['weight']) ? $data['menu_link']['weight'] : (db_query("SELECT MAX(weight) FROM {menu_links} WHERE menu_name = :menu_name", array(':menu_name' => $data['menu']))->fetchField() + 1),
      // @todo Allow caller to specify a non-empty description.
      'description' => '',
    );
  }

  // Add any fields.
  if (isset($data['fields'])) {
    foreach ($data['fields'] as $field_name => $field_data) {
      $node->{$field_name}[LANGUAGE_NONE] = $field_data;
    }
  }

  // A PHP notice is triggered by forum_node_presave() if nid is undefined.
  if (!isset($node->nid)) {
    $node->nid = NULL;
  }

  // As a workaround for the issue discussed at http://drupal.org/node/682552,
  // we need to rebuild the node types during installation before trying to
  // save a new node (otherwise node types defined by modules which were just
  // enabled earlier in the installation might not have their fields saved
  // correctly). Note that even after the patch in the above issue is
  // committed, we probably still need to continue doing this, since the real
  // bug here is essentially http://drupal.org/node/651086.
  node_types_rebuild();

  node_save($node);
  return $node;
}

/**
 * Returns a standard instance definition for our Gardens image field.
 *
 * Based partially on the standard install profile.
 *
 * @param $type
 *   The node type which the image will be attached to.
 */
function site_template_standard_image_instance($type) {
  $instance = array(
    'field_name' => 'field_image',
    'entity_type' => 'node',
    'label' => 'Image',
    'bundle' => $type,
    'description' => '',
    'required' => FALSE,
    'settings' => array(
      'file_directory' => 'field/image',
      'file_extensions' => 'png gif jpg jpeg',
      'max_filesize' => '',
      'max_resolution' => '',
      'min_resolution' => '',
      'alt_field' => TRUE,
      'title_field' => '',
    ),
    'widget' => array(
      'type' => 'image_image',
      'settings' => array(
        'progress_indicator' => 'throbber',
        'preview_image_style' => 'thumbnail',
      ),
      'weight' => -1,
    ),
    'display' => array(
      'default' => array(
        'label' => 'hidden',
        'type' => 'image',
        'settings' => array('image_style' => 'large', 'image_link' => ''),
        'weight' => -1,
      ),
      'teaser' => array(
        'label' => 'hidden',
        'type' => 'image',
        'settings' => array('image_style' => 'large', 'image_link' => ''),
        'weight' => -1,
      ),
      'rss' => array(
        'label' => 'hidden',
        'type' => 'image',
        'settings' => array('image_style' => 'large', 'image_link' => ''),
        'weight' => -1,
      ),
      'search_index' => array(
        'label' => 'hidden',
        'type' => 'image',
        'settings' => array('image_style' => 'large', 'image_link' => ''),
        'weight' => -1,
      ),
      'search_results' => array(
        'label' => 'hidden',
        'type' => 'image',
        'settings' => array('image_style' => 'large', 'image_link' => ''),
        'weight' => -1,
      ),
    ),
  );
  return $instance;
}

/**
 * Copies a site template file asset to the public files directory.
 *
 * If the file is already there, it is left alone. If it's not already there,
 * it is copied and recorded as a managed file.
 *
 * @param $feature_folder
 *   The folder within 'site_template/assets' that the original asset lives in,
 *   corresponding to the feature the asset is associated with.
 * @param $filename
 *   The name of the file within that folder. It will have the same name when
 *   copied to the public files directory.
 * @param $public_subdir
 *   (optional) The subdirectory within the public folder where this will be
 *   stored.
 *
 * @return
 *   The file object.
 */
function site_template_copy_asset($feature_folder, $filename, $public_subdir = NULL) {
  // This file probably doesn't exist already, but checking for it makes
  // testing easier and couldn't hurt.
  $file_uri = isset($public_subdir) ? "public://$public_subdir/$filename" : "public://$filename";
  $files = file_load_multiple(array(), array('uri' => $file_uri));
  if ($files) {
    $file = array_shift($files);
  }
  else {
    if (isset($public_subdir)) {
      // Make sure the subdirectory exists and is set up correctly.
      $public_subdir_uri = "public://$public_subdir";
      file_prepare_directory($public_subdir_uri, FILE_CREATE_DIRECTORY);
    }
    copy(drupal_get_path('module', 'site_template')  . "/assets/$feature_folder/$filename", $file_uri);
    $file = file_uri_to_object($file_uri);
    file_save($file);
  }
  return $file;
}

/**
 * Prepares a basic comment by an anonymous user, with given subject and body.
 */
function site_template_prepare_basic_comment($subject, $body) {
  // Use the default text format for anonymous users.
  $formats = filter_get_formats_by_role(DRUPAL_ANONYMOUS_RID);
  $format = reset($formats);
  $format = $format->format;
  $time = time();
  $comment = (object) array(
    'subject' => $subject,
    'uid' => 0,
    'language' => LANGUAGE_NONE,
    'comment_body' => array(
      LANGUAGE_NONE => array(
        0 => array(
          'value' => $body,
          'format' => $format,
        ),
      ),
    ),
    'created' => $time,
    'changed' => $time,
    'status' => COMMENT_PUBLISHED,
  );
  return $comment;
}

/**
 * Adds a node type.
 *
 * @param $type_data
 *   An array of data about the node type. Common options are:
 *   - 'type': The machine-readable name of the node type.
 *   - 'name': The human-readable name of the node type.
 *   - 'description': A description of the node type.
 *   - 'title_label': A label for the title field.
 *   - 'body_label': A label for the body field. If provided, a standard body
 *     field with this label will be added and attached to this node type. If
 *     not provided, the node type will not get a body field at all.
 * @param $save_variables
 *   Whether to save a common set of variables for comments, published status,
 *   etc.
 */
function site_template_add_node_type($type_data, $save_variables = TRUE) {
  // Create the content type and save its associated RDF mapping.
  $type_data += array(
    'base' => 'node_content',
    'custom' => 1,
    'modified' => 1,
    'locked' => 0,
  );
  if (isset($type_data['rdf_mapping'])) {
    $rdf_mapping = $type_data['rdf_mapping'];
    unset($type_data['rdf_mapping']);
  }
  else {
    // This is what the standard install profile does for page nodes, so we
    // should probably do it here too :)
    $rdf_mapping = array(
      'mapping' => array(
        'rdftype' => array('foaf:Document'),
      ),
    );
  }
  $rdf_mapping += array(
    'type' => 'node',
    'bundle' => $type_data['type'],
  );
  if (isset($type_data['body_label'])) {
    $body_label = $type_data['body_label'];
    unset($type_data['body_label']);
  }
  $type = node_type_set_defaults($type_data);
  node_type_save($type);
  rdf_mapping_save($rdf_mapping);
  if (isset($body_label)) {
    $types = node_type_get_types();
    node_add_body_field($types[$type_data['type']], $body_label);
  }

  if ($save_variables) {
    // Configure the content type in a similar way as the standard install
    // profile does for page nodes.
    $node_type = $type_data['type'];
    variable_set("node_options_{$node_type}", array('status'));
    variable_set("comment_{$node_type}", COMMENT_NODE_HIDDEN);
    variable_set("node_submitted_{$node_type}", FALSE);
  }
}

/**
 * Enable a block.
 *
 * @param $block
 *   An array representing the block, with the following keys.
 *   - module: The name of the module defining the block.
 *   - delta: The delta of the block within that module.
 *   - region: The region of the page in which the block should be placed.
 *     If an array of regions is provided, the first one that is currently
 *     empty of blocks will be substituted (and if none are empty, the last
 *     will be used).
 *   - title: (Optional) The title of the block.
 *   - weight: (Optional) The weight of the block within that region. Defaults
 *     to inserting the block as the last one in the region.
 *   - theme: (Optional) The theme in which the block should be enabled.
 *     Defaults to the main site theme.
 *   - pages: (Optional) An array containing paths or expressions for
 *     drupal_match_path(), representing the pages that the block will be
 *     restricted to. Defaults to showing the block on all pages.
 *
 * @return
 *   TRUE if the block was newly-enabled, FALSE otherwise.
 */
function site_template_enable_block(&$block) {
  // If the block does not specify a theme, use the main site theme.
  if (!isset($block['theme'])) {
    $block['theme'] = variable_get('theme_default', 'bartik');
  }

  // We require that a region be specified.
  if (!isset($block['region'])) {
    return FALSE;
  }

  // If an array of regions is given, choose the first empty one (or the last
  // one if none are empty).
  if (is_array($block['region'])) {
    foreach ($block['region'] as $region) {
      $populated = db_query("SELECT 1 FROM {block} WHERE region = :region AND theme = :theme AND status = 1", array(':region' => $region, ':theme' => $block['theme']))->fetchField();
      if (!$populated) {
        break;
      }
    }
    $block['region'] = $region;
  }

  // Do not try to enable a block if the requested region does not exist in the
  // theme.
  $theme_regions = array_keys(system_region_list($block['theme']));
  if (!in_array($block['region'], $theme_regions)) {
    return FALSE;
  }

  // Determine the status of each block in this theme, and store the highest
  // weight of any block in the requested theme region.
  $theme_blocks = _block_rehash($block['theme']);
  $block_status = array();
  $max_weight = 0;
  foreach ($theme_blocks as $theme_block) {
    $block_status[$theme_block['module']][$theme_block['delta']] = $theme_block['status'];
    if ($theme_block['region'] == $block['region']) {
      $max_weight = max($max_weight, $theme_block['weight']);
    }
  }

  // Only install the requested block if it exists.
  if (!isset($block_status[$block['module']][$block['delta']])) {
    return FALSE;
  }

  // Enable the block for the specified region. If it's already enabled, don't
  // change the existing weight and title unless they were explicitly provided.
  $already_enabled = !empty($block_status[$block['module']][$block['delta']]);
  $fields = array(
    'status' => 1,
    'region' => $block['region'],
  );
  if (isset($block['weight']) || !$already_enabled) {
    // Blocks that do not have specific weights default to appearing at the end
    // of the list for this page region.
    $fields['weight'] = isset($block['weight']) ? $block['weight'] : $max_weight + 1;
  }
  if (isset($block['title']) || !$already_enabled) {
    $fields['title'] = isset($block['title']) ? $block['title'] : '';
  }

  $updated = db_update('block')
    ->fields($fields)
    ->condition('module', $block['module'])
    ->condition('delta', $block['delta'])
    ->condition('theme', $block['theme'])
    ->execute();

  // Optionally restrict the block to certain pages.
  if (isset($block['pages'])) {
    site_template_restrict_block_to_pages($block['module'], $block['delta'], $block['pages']);
  }

  return (bool) $updated;
}

/**
 * Disable a block.
 *
 * @param $block
 *   An array representing the block, containing at least the keys 'module',
 *   'delta', and 'theme'.
 */
function site_template_disable_block($block) {
  db_update('block')
    ->fields(array(
      'status' => 0,
      'region' => '',
    ))
    ->condition('module', $block['module'])
    ->condition('delta', $block['delta'])
    ->condition('theme', $block['theme'])
    ->execute();
}

/**
 * Restricts an existing block to certain pages.
 *
 * @param $module
 *   The name of the module defining the block.
 * @param $delta
 *   The delta of the block within that module.
 * @param $pages
 *   An array containing paths or expressions for drupal_match_path(),
 *   representing the pages that the block will be restricted to.
 */
function site_template_restrict_block_to_pages($module, $delta, $pages) {
  $pages = implode("\r\n", $pages);
  db_update('block')
    ->fields(array(
      'visibility' => 1,
      'pages' => $pages,
    ))
    ->condition('module', $module)
    ->condition('delta', $delta)
    ->execute();
}

/**
 * Saves a menu link while installing a site template.
 *
 * This function allows us work around Drupal cache clearing bugs that would
 * otherwise require us to call menu_rebuild() every time we wanted to save a
 * menu link for a module that we just enabled in a site template feature. The
 * function behaves exactly like menu_link_save(), but checks afterwards to
 * make sure the item has a router path, and if not, forces the router path to
 * be equal to the link path. If we didn't do this, then the next call to
 * menu_rebuild() would result in the link being deleted.
 *
 * Note that this function should *not* be called for paths that we do not
 * expect to have an associated router path - for example, <front>. In those
 * cases, use menu_link_save() directly instead.
 *
 * @param $item
 *   An array representing a menu link item, for passing to menu_link_save().
 *
 * @return
 *   The mlid of the saved menu link, or FALSE if the menu link could not be
 *   saved.
 */
function site_template_menu_link_save(&$item) {
  $mlid = menu_link_save($item);
  if (!$mlid) {
    return FALSE;
  }
  $router_path = db_query("SELECT router_path FROM {menu_links} WHERE mlid = :mlid", array(':mlid' => $mlid))->fetchField();
  if (empty($router_path)) {
    db_query("UPDATE {menu_links} SET router_path = link_path WHERE mlid = :mlid", array(':mlid' => $mlid));
  }
  return $mlid;
}

/**
 * Creates a basic role.
 *
 * @param $name
 *   The name of the role.
 * @param $permissions
 *   An array of permissions to assign the role. Only those permissions which
 *   actually exist are granted, since currently, user_role_grant_permissions()
 *   does not handle non-existent permissions well; see, for example,
 *   http://drupal.org/node/737816).
 *
 * @return
 *   The role ID of the new role.
 */
function site_template_add_basic_role($name, $permissions) {
  $role = new stdClass();
  $role->name = $name;
  // As long as the role name comes after "A" in the alphabet, setting a weight
  // of 1 tends to put it by default between the low level (anonymous and
  // authenticated) and high level (administrator and site maintainer) roles,
  // which is where we usually want it.
  $role->weight = 1;
  user_role_save($role);
  // Only grant permissions that exist.
  $permissions = array_intersect($permissions, array_keys(module_invoke_all('permission')));
  user_role_grant_permissions($role->rid, $permissions);
  return $role->rid;
}

/**
 * Creates a complete SimpleView and associated storage data.
 *
 * @param $simpleview_data
 *   An array representing data for the SimpleView and its backend storage
 *   mechanism. Keys can be anything that appears in the database tables
 *   {simpleviews} and {simpleviews_sqbs}; typical ones are 'path', 'title'
 *   'filter', 'block', 'page_items', 'block_items', etc.  In addition,
 *   'menu_link' can be set to a menu link that will be associated with
 *   the SimpleView. The link path and link title are obtained from the main
 *   SimpleView 'path' and 'title' if not specified explicitly.
 *
 * @return
 *   An array containing the following keys:
 *   - simpleview_id: The ID of the new SimpleView in the {simpleviews} table
 *   - sqbs_id: The ID of the new SimpleView in the {simpleviews_sqbs} table
 *   - mlid: The ID of the associated menu link (only if one was created)
 */
function site_template_create_simpleview($simpleview_data) {
  // Save the simpleview and sqbs backend data.
  $simpleview = simpleviews_item_save($simpleview_data);
  $return_data['simpleview_id'] = $simpleview['svid'];
  unset($simpleview['svid']);
  $return_data['sqbs_id'] = sqbs_simpleviews_save($simpleview);
  // Optionally add a menu link.
  if (isset($simpleview_data['menu_link'])) {
    $menu_link = $simpleview_data['menu_link'];
    if (isset($simpleview_data['path'])) {
      $menu_link += array('link_path' => $simpleview_data['path']);
    }
    if (isset($simpleview_data['title'])) {
      $menu_link += array('link_title' => $simpleview_data['title']);
    }
    if ($mlid = site_template_menu_link_save($menu_link)) {
      $return_data['mlid'] = $mlid;
    }
  }
  return $return_data;
}

/**
 * Deletes a complete SimpleView and its associated storage data.
 *
 * @param $simpleview_data
 *   An array containing keys 'simpleview_id', 'sqbs_id', and, optionally,
 *   'mlid', as returned from site_template_create_simpleview().
 *
 * @see site_template_create_simpleview()
 */
function site_template_delete_simpleview($simpleview_data) {
  simpleviews_item_delete($simpleview_data['simpleview_id']);
  sqbs_simpleviews_delete($simpleview_data['sqbs_id']);
  if (isset($simpleview_data['mlid'])) {
    menu_link_delete($simpleview_data['mlid']);
  }
}

/**
 * Force anonymous users to provide their contact info on all or some node types.
 *
 * @param $node_types
 *   An optional array of node types. If not provided, all current node types
 *   on the site will have this value set.
 *
 * @return
 *   An array of the previous variables storing the anonymous user comment
 *   settings, before the changes made here. This array is in the format
 *   returned by site_template_get_variable_states().
 */
function site_template_force_anonymous_contact($node_types = NULL) {
  if (!isset($node_types)) {
    $node_types = array_keys(node_type_get_types());
  }
  $variables = array();
  foreach ($node_types as $type) {
    $variables[] = 'comment_anonymous_' . $type;
  }
  $variable_states = site_template_get_variable_states($variables);
  foreach ($variables as $variable) {
    if (variable_get($variable) !== COMMENT_ANONYMOUS_MUST_CONTACT) {
      variable_set($variable, COMMENT_ANONYMOUS_MUST_CONTACT);
    }
  }
  return $variable_states;
}

/**
 * Enable comment notification on all or some node types.
 *
 * @param $node_types
 *   An optional array of node types. If not provided, all current node types
 *   on the site will have this value set.
 *
 * @return
 *   An array of the previous variables storing the comment notification
 *   settings, before the changes made here. This array is in the format
 *   returned by site_template_get_variable_states().
 */
function site_template_enable_comment_notification($node_types = NULL) {
  if (!isset($node_types)) {
    $node_types = array_keys(node_type_get_types());
  }
  $variables = array('comment_notify_node_types');
  $variable_states = site_template_get_variable_states($variables);
  $comment_notify_node_types = variable_get('comment_notify_node_types', array());
  $comment_notify_node_types += drupal_map_assoc($node_types);
  variable_set('comment_notify_node_types', $comment_notify_node_types);
  return $variable_states;
}

/**
 * @} End of "defgroup site_template_features_api".
 */

/**
 * @defgroup site_template_devel Developer features for site templates.
 * @{
 */

/**
 * Menu callback for developers to test switching between site templates.
 */
function site_template_debug_form($form, &$form_state) {
  $templates = site_template_get_all_templates();
  $options = array();
  foreach ($templates as $key => $info) {
    $options[$key] = $info['name'];
  }

  $form['template'] = array(
    '#type' => 'radios',
    '#title' => 'Template',
    '#options' => $options,
    '#default_value' => site_template_current_template(),
    '#weight' => -5,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit'
  );

  return $form;
}

function site_template_debug_form_submit(&$form, &$form_state) {
  $template_chosen = $form_state['values']['template'];
  site_template_uninstall_features(site_template_current_template());
  site_template_install_features($template_chosen);
}

/**
 * Implements hook_siteinfo();
 */
function site_template_siteinfo() {
  return array('template' => variable_get('site_template_current_template'));
}

/**
 * @} End of "defgroup site_template_devel".
 */
