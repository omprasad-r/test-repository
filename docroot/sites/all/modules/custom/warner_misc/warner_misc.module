<?php

/**
 * @file
 * Miscellaneous functionality for Warner.
 *
 * Note: It is rarely (if ever) a good idea to put any code in this module! We
 * are trying *not* to have customer-specific code in Gardens. Plus, it is not
 * included on site export. Instead, use this module mainly just to enable
 * other general-purpose modules in the Gardens codebase which the customer
 * needs.
 */

/**
 * Implements hook_menu().
 */
function warner_misc_menu() {
  $items = array();

  $items['report-session-count/%/%'] = array(
    'title' => 'Status',
    'description' => 'Get the past 24 hours of session counts.',
    'access callback' => 'warner_misc_stats_access',
    'access arguments' => array(2),
    'page callback' => 'warner_misc_report_session_count',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/content/wysiwyg_customization'] = array(
    'title' => 'Wysiwyg customization',
    'description' => 'Customize wysiwyg settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('warner_misc_wysiwyg_settings_form'),
    'access callback' => 'warner_misc_wysiwyg_customization_access',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Access callback for WYSIWYG customization form.
 */
function warner_misc_wysiwyg_customization_access() {
  return user_access('administer filters') && module_exists('wysiwyg');
}

/**
 * Form constructor for the Wysiwyg customization form.
 */
function warner_misc_wysiwyg_settings_form($form, &$form_state) {
  $form['warner_misc_wysiwyg_comment_form_buttons']= array(
    '#type' => 'fieldset',
    '#title' => t('Wysiwyg comment form button settings'),
    '#description' => t('Here you can manage WYSIWYG buttons that are applied for comment forms only. All buttons enabled on the wysiwyg profile are fetched and listed in groups. Select the ones you would like to use on comment forms.'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
  );

  // Get all filter formats.
  $filter_formats = filter_formats();
  $options = array();

  foreach (wysiwyg_profile_load_all() as $format => $profile) {
    // Get plugin metadata for selected editor.
    $plugins = wysiwyg_get_plugins($profile->editor);

    $form['warner_misc_wysiwyg_comment_form_buttons'][$format] = array(
      '#type' => 'fieldset',
      '#title' => t('Enabled editor buttons in comments for @filter_format', array('@filter_format' => $filter_formats[$format]->name)),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#theme' => 'warner_misc_admin_button_table',
    );

    if (!empty($profile->settings) && isset($filter_formats[$format])) {
      // Get custom settings.
      $options[$format] = variable_get('warner_misc_comment_form_buttons_for_' . $format, array());

      foreach ($plugins as $name => $meta) {
        if (isset($meta['buttons']) && is_array($meta['buttons'])) {
          foreach ($meta['buttons'] as $button => $title) {
            $form['warner_misc_wysiwyg_comment_form_buttons'][$format]['buttons'][$button] = array(
              '#type' => 'checkbox',
              '#title' => $title,
              '#default_value' => isset($options[$format][$button]) ? $options[$format][$button] : 0,
            );
          }
        }
      }
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 100,
  );

  return $form;
}

/**
 * Form submission handler for warner_misc_wysiwyg_settings_form().
 */
function warner_misc_wysiwyg_settings_form_submit($form, &$form_state) {
  $values = $form_state['values'];

  foreach ($values['warner_misc_wysiwyg_comment_form_buttons'] as $input_format => $settings) {
    if (isset($settings['buttons'])) {
      $settings['buttons'] = array_filter($settings['buttons']);
      variable_set('warner_misc_comment_form_buttons_for_' . $input_format, $settings['buttons']);
    }
  }
  wysiwyg_profile_cache_clear();

  drupal_set_message(t('Wysiwyg customized settings have been saved.'));

  $form_state['redirect'] = 'admin/config/content/wysiwyg_customization';
}

/**
 * Returns HTML for a 3-column button table layout.
 */
function theme_warner_misc_admin_button_table($variables) {
  $form = $variables['form'];
  $buttons = array();

  // Flatten forms array.
  foreach (element_children($form) as $name) {
    foreach (element_children($form[$name]) as $button) {
      $buttons[] = drupal_render($form[$name][$button]);
    }
  }

  // Split checkboxes into rows with 3 columns.
  $total = count($buttons);
  $rows = array();
  for ($i = 0; $i < $total; $i += 3) {
    $row = array();
    $row_buttons = array_slice($buttons, $i, 3) + array_fill(0, 3, array());
    foreach ($row_buttons as $row_button) {
      $row[] = array('data' => $row_button);
    }
    $rows[] = $row;
  }

  $output = theme('table', array('rows' => $rows, 'attributes' => array('width' => '100%')));

  return $output;
}

/**
 * Implements hook_theme().
 */
function warner_misc_theme() {
  return array(
    'warner_misc_membership_stats' => array(
      'variables' => array('member_count' => 0, 'fan_member_count' => 0, 'new_member_count' => 0, 'inactive_member_count' => 0),
    ),
    'warner_misc_admin_button_table' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_page_alter().
 */
function warner_misc_page_alter(&$build) {
  // See if we're on the front page:
  // drupal_is_front_page() won't work if the front page is requested
  // but a custom 403 page is returned because $_GET['q'] will be changed
  // to match the custom 403 path. Instead, we need to check $_SERVER.
  if (($_SERVER['REQUEST_URI'] == base_path()) || ($_SERVER['REQUEST_URI'] == base_path() . '/' . variable_get('site_frontpage', 'node'))) {
    // See if the user is anonymous
    if (user_is_anonymous()) {
      // Fetch the menu item
      if ($menu = menu_get_item()) {
        // See if access was denied
        if (!$menu['access']) {
          // Change the status code to 200 so search engines will
          // continue to index this page
          drupal_add_http_header('Status', '200 OK');
        }
      }
    }
  }
}

/**
 * Access callback to ensure that the request came from a legitimate source.
 */
function warner_misc_stats_access($hash) {
  if (md5('gardens-http://' . $_SERVER['HTTP_HOST']) == $hash) {
    return TRUE;
  }
}

/**
 * Implements hook_disallowed_modules_alter().
 *
 * Allow Janrain, Gardens moderation and Gardens site variables to be enabled.
 */
function warner_misc_disallowed_modules_alter(&$modules) {
  // Modules that come with the distro and are disallowed by default but should
  // be allowed here.
  $modules = array_diff($modules, array(
    'gardens_moderation',
    'gardens_mail_media',
    'gardens_site_variables',
    'janrain_client',
    'janrain_login',
    'mast',
    'date_migrate',
    'migrate',
    'migrate_ui',
    'migrate_extras',
    'migrate_d2d',
    'migrate_d2d_ui',
    'migrate_warner',
    'migrate_aa',
    'migrate_googoo',
    'migrate_nonesuch',
  ));

  // Modules that are not in the distro but are add-ons in this codebase and
  // should not show up in the UI.
  $extra_disallowed_modules = array(
    'bulk_email',
    'coppa_lite',
    'mailhandler',
    'mailhandler_default',
    'mailhandler_php_imap',
    'mailhandler_tokenauth', // Cannot be removed from disallowed - unmet dependency
    'mailhandler_medialink',
    'mailhandler_sendto_auth',
    'privatemsg_realname',
    'privatemsg_rules',
    'mailhandler_singlemailbox',
    'mailhandler_multiple_email',
    'mailhandler_extended',
    'mail_media',
    'job_scheduler',
    'member_api',
    'uuid',
    'uuid_services',
    'uuid_services_example',
    'shield',
    'site_guard',
    'views_rss_dc',
    'getid3',
  );
  $modules = array_merge($modules, $extra_disallowed_modules);
}

/**
 * Implements hook_simplified_modules_hidden_submodules().
 */
function warner_misc_simplified_modules_hidden_submodules() {
  return array(
    'janrain_capture_screens',
    // Prevent the Views RSS and Views RSS Core modules from appearing on the
    // Modules page, but turn them on automatically whenever Views (which they
    // depend on) is enabled.
    'views_rss',
    'views_rss_core',
    'views_rss_itunes',
  );
}

/**
 * Implements hook_file_formatter_info_alter().
 */
function warner_misc_file_formatter_info_alter(&$formatters) {
  if (isset($formatters['media_oembed'])) {
    $formatters['media_oembed']['default settings']['wmode'] = 'transparent';
    $formatters['media_oembed']['view callback'] = 'warner_misc_file_formatter_media_oembed_view';
  }
  if (isset($formatters['media_oembed_thumbnail'])) {
    $formatters['media_oembed_thumbnail']['view callback'] = 'warner_misc_file_formatter_media_oembed_thumbnail_view';
  }
  if (isset($formatters['media_oembed_thumbnail_style'])) {
    $formatters['media_oembed_thumbnail_style']['view callback'] = 'warner_misc_file_formatter_media_oembed_thumbnail_style_view';
  }
}

/**
 * Implements hook_file_formatter_FORMATTER_view().
 *
 * Decorator for media_oembed_file_formatter_media_oembed_view() that adds a post-render
 * for adding wmode=transparent to all embeds.
 */
function warner_misc_file_formatter_media_oembed_view($file, $display, $langcode) {
  $element = media_oembed_file_formatter_media_oembed_view($file, $display, $langcode);
  $scheme = file_uri_scheme($file->uri);
  if ($scheme == 'oembed') {
    $element['#post_render'][] = 'warner_misc_oembed_post_render';
    $element['#cache']['expire'] = CACHE_PERMANENT;
  }
  return $element;
}

/**
 * Implements hook_file_formatter_FORMATTER_view().
 *
 * Decorator for media_oembed_file_formatter_media_oembed_thumbnail_view() that
 * forces CACHE_PERMANENT for all oembed thumbs.
 */
function warner_misc_file_formatter_media_oembed_thumbnail_view($file, $display, $langcode) {
  $element = media_oembed_file_formatter_media_oembed_thumbnail_view($file, $display, $langcode);
  $scheme = file_uri_scheme($file->uri);
  if ($scheme == 'oembed') {
    $element['#cache']['expire'] = CACHE_PERMANENT;
  }
  return $element;
}

/**
 * Implements hook_file_formatter_FORMATTER_view().
 *
 * Decorator for media_oembed_file_formatter_media_oembed_thumbnail_style_view() that
 * forces CACHE_PERMANENT for all oembed thumbs.
 */
function warner_misc_file_formatter_media_oembed_thumbnail_style_view($file, $display, $langcode) {
  $element = media_oembed_thumbnail_style_file_formatter_view($file, $display, $langcode);
  $scheme = file_uri_scheme($file->uri);

  if ($scheme == 'oembed') {
    $url = drupal_realpath($file->uri);

    // Facebook url is to be themed without image_style.
    if (strpos($url, 'facebook')) {

      // Append a trailing slash in the url.
      if (strrpos($url, '/?hc_ref=NEWSFEED') === FALSE && (strlen($url) - strrpos($url, '/')) != 1) {
        $url .= '/';
      }
      preg_match('/\/(?:t\.\d+\/)?(\d+)\//i' , $url, $video_id);
      $video_id = trim($video_id[0], '/');
      $file->uri = trim($url, '/');

      $element = array(
        '#cache' => array(
          'expire' => CACHE_PERMANENT
        ),
        '#theme' => 'image',
        '#path' => 'https://graph.facebook.com/' . $video_id . '/picture',
      );
    }
    else if (strpos($url, 'vimeo')) {
      $url = trim($url, '/');
      preg_match('/\/(\d+)/i', $url, $video_id);
      $video_id = trim($video_id[0], '/');

      // Fetch vimeo thumbnail.
      $json = file_get_contents('http://vimeo.com/api/v2/video/' . $video_id . '.json');
      $response = drupal_json_decode($json);

      $element = array(
        '#cache' => array(
          'expire' => CACHE_PERMANENT
        ),
        '#theme' => 'image',
        '#path' => $response[0]['thumbnail_small'],
      );
    }
    else {
      $element['#cache']['expire'] = CACHE_PERMANENT;
    }
  }
  return $element;
}

/**
 * Force wmode=transparent on all Warner oembed embed fields.
 */
function warner_misc_oembed_post_render($element) {
  include_once(drupal_get_path('module', 'warner_misc') . '/includes/forceWMode.inc');
  $element = _warner_misc_force_wmode_clean_data($element, 'transparent');
  return $element;
}

/**
 * Implements hook_preprocess_image().
 */
function warner_misc_preprocess_image(&$variables) {
  // This is mostly a copy of remote_stream_wrapper_preprocess_image() to avoid
  // having broken images on an http page when image url is cached as https.
  // In warner_misc_file_formatter_info_alter we are setting some media
  // formatters to add some extra settings to them. The interesting one is
  // warner_misc_file_formatter_media_oembed_thumbnail_style_view() which is
  // enabling the site to use derivatives of 3rd party images. The oembed
  // modules are caching some data to avoid querying 3rd party sites all the
  // time (see oembedcore_render_cache) but this does not distinguish if the
  // cache is for https or http page, so when a page is generated for an https
  // url and an image derivative is being generated for a 3rd party media then
  // the cache will store the image with an https url even when it's being used
  // for an http page. This leads to a broken images since our SSL certs usually
  // need accepting. This could be fixed by altering the cache keys, but there's
  // an other feature making life hard. The media module supports inserting some
  // macros into node bodies which gets transformed into actual images via the
  // core filter functionality which is again cached similarly - does not
  // differentiate between http and https. In such cases filters disable the
  // caching for the format, but that would be a performance hit in our case.
  // We could try to use relative paths but in case the content would be used on
  // a 3rd party site as part of a widget that would lead to a broken image as
  // well. The current approach will be to force images to http. This is not
  // ideal either since a browser loading an https page with components from
  // http could complain. see DG-5571.
  if (!empty($GLOBALS['is_https']) && !empty($variables['style_name']) && !empty($variables['source_path'])) {
    if (module_exists('remote_stream_wrapper') && file_is_scheme_remote(file_uri_scheme($variables['source_path']))) {
      $url = file_create_url(remote_stream_wrapper_image_style_path($variables['style_name'], $variables['source_path']));
      if (strpos($url, $GLOBALS['base_secure_url']) === 0) {
        $variables['path'] = str_replace($GLOBALS['base_secure_url'], $GLOBALS['base_insecure_url'], $url);
      }
    }
  }
}

/**
 * Implements hook_page_build().
 */
function warner_misc_init() {
  $path = drupal_get_path('module', 'warner_misc');
  // Common styling for overlay dialogs on Warner sites.
  // @todo, change the default to FALSE before launching.
  if (variable_get('warner_common_dialog_css', FALSE)) {
    drupal_add_css($path . '/css/wmg.ui.dialog.css', array('group' => CSS_DEFAULT, 'every_page' => TRUE));
  }

  // Variables forced for Warner.
  // Make sure the views data export temporary file location is in gluster.  gardens_temp
  // conveniently is already handled in site export also (is used by mailhandler).
  $GLOBALS['conf']['views_data_export_directory'] = 'public://gardens_temp';

  // Force Warner to scan incoming emails for links in both the plaintext and
  // HTML parts. This became necessary when IFTTT added a click tracker to the
  // link in the plaintext part of their emails. It is present also in the href
  // of the link in the HTML part, but the unaltered link is the text of that
  // <a>, so we can get it from there. We have to depend on media_internet to
  // sort out usable links from there.
  if (!isset($GLOBALS['conf']['mailhandler_medialink_mail_parts'])) {
    $GLOBALS['conf']['mailhandler_medialink_mail_parts'] = array(
      'body_text' => 1,
      'body_html' => 1,
    );
  }
}

/**
 * Implements hook_theme_registry_alter()
 * @param array $theme_registry
 */
function warner_misc_theme_registry_alter(&$theme_registry) {

  // path to the wmg theme
  $wmg_theme_path = drupal_get_path('theme', 'wmg');

  // make sure the theme is available and can be accessed
  if(!file_exists($wmg_theme_path)) {
    return;
  }

  // figure out the config path for the current web node.
  $config_path = conf_path();
  $config_length = strlen($config_path);

  // walk through each hook to the registry
  foreach ($theme_registry as $hook => $details) {

    // change behaviour based on whether it's a theme or module
    switch ($details['type']) {
      case 'theme_engine':

        // make sure you are selecting the proper element.
        if (substr($details['theme path'], 0, $config_length)
                === $config_path) {
          $tpl_new_path = $wmg_theme_path
                          . '/'
                          . $details['template']
                          . '.tpl.php';

          // does the template file exists?
          if(file_exists($tpl_new_path)) {
            // TODO: Figure out whether both should be changed or only one.
            $details['theme path'] = $wmg_theme_path;
            $details['path'] = $wmg_theme_path;
          }
        }


        break;
      default:
        // nothing to do...
        break;
    }
  }
}

/**
 * Implements hook_simplified_modules_hidden_dependencies().
 */
function warner_misc_simplified_modules_hidden_dependencies() {
  return array(
    // Hide the gardens site variables module as a hidden dependency.
    'gardens_site_variables',
  );
}

/**
 * Implements hook_library().
 */
function warner_misc_library() {
  $path = drupal_get_path('module', 'warner_misc');
  // Register the debug jQuery plugin as a library.
  $libraries['prevent_multiple_clicks'] = array(
    'title' => 'Prevents multiple clicks in comment forms.',
    'website' => 'http://www.drupalgardens.com',
    'version' => '1.00',
    'js' => array(
      $path . '/plugins/prevent-multiple-clicks/prevent-multiple-clicks.js' => array('group' => JS_THEME, 'every_page' => TRUE,),
    ),
  );
  return $libraries;
}

/**
 * Implements hook_javascript_libraries_available_alter().
 */
function warner_misc_javascript_libraries_available_alter(&$groups) {
  $groups['Theme plugins']['library'][] = 'prevent_multiple_clicks';
}

/**
 * Implements default_oembedcore_provider_alter().
 *
 * Enables the youtube provider by default and reassigns some of the embedly-handled
 * urls to the youtube handler.
 */
function warner_misc_default_oembedcore_provider_alter(&$providers) {
  // The youtube provider is disabled by default - enabled it.
  $providers['youtube']->disabled = FALSE;

  // These regular expressions are being taken from the embed.ly provider and given
  // back to the youtube provider so that it handles the majority of normal youtube
  // embeds, rather than embed.ly, which charges per API call.  The original regexps
  // are obtained in oembedembedly_default_oembedcore_provider() via an API call to
  // http://api.embed.ly/1/services . There are some patterns which youtube themselves
  // do not handle over oembed, so these are left with the embed.ly provider.
  $providers['youtube']->scheme = "http://*youtube.com/watch*\n"
    . "https://*youtube.com/watch*\n"
    . "http://youtu.be/*\n"
    // This next pattern was copied from the original embedly patterns list, but it's
    // pointless, as it's covered by the wildcards above.
    //  . "http://m.youtube.com/watch*\n"

    // Removed "." to catch bare domain.
    . "http://*youtube.com/playlist*";

  // Leave embedly enabled to handle urls that youtube do not or no longer handle.
  $providers['oembedembedly_youtube']->scheme = "http://*youtube.com/view_play_list*\n"
    // Removed the "." from the default on all of these to also catch the bare domain.
    . "http://*youtube.com/v/*\n"
    . "http://m.youtube.com/index*\n"
    . "http://*youtube.com/profile*\n"
    . "https://*youtube.com/v/*\n"
    . "http://*youtube.com/user/*\n"
    . "http://*youtube.com/*#*/*";
}

/**
 * Implements hook_oembed_request_alter().
 */
function warner_misc_oembed_request_alter(&$attributes, &$provider, &$url) {
  // Youtube's own oembed endpoint does not directly support /v/<video> urls that
  // embedly does support.  In order to reduce on costly API calls (as we have a
  // lot of these urls in Warner), we attempt to translate the url into something
  // youtube can handle here,  and if successful, we swap out the underlying provider
  // before the request goes out.  Youtube's endpoint is happiest if all urls are
  // of the form /watch?v=<video> .
  if ($provider['name'] == 'oembedembedly_youtube') {
    $url_parts = parse_url($url);
    // If the url path contains more than one part (I've never seen this happen),
    // let embedly work out what to do with it, otherwise convert this to a url
    // that the youtube endpoint can handle.
    if (preg_match('@/v/([^/]+)$@', $url_parts['path'], $matches)) {
      $youtube_provider = oembedcore_provider_load('youtube');
      if (!empty($youtube_provider) && !$youtube_provider->disabled) {
        $provider = (array) $youtube_provider;
        $url_parts['query'] = 'v=' . $matches[1] . '&' . $url_parts['query'];
        $url = $url_parts['scheme']
          . '://' . $url_parts['host']
          . '/watch?' . $url_parts['query']
          . (!empty($url_parts['fragment']) ? '#' . $url_parts['fragment'] : '');
        unset($attributes['key']);
      }
    }
  }

  // If iframe=0 is not specified, youtube returns an iframe, which is immune to
  // all our wmode=transparent tweaks.
  if ($provider['name'] == 'youtube') {
    $attributes['iframe'] = 0;
  }

  // Just for good measure, force wmode parameter (this can save 1 API request per
  // provider if the *validation* calls match the actual embed calls). It's ignored
  // by most providers, but honoured by emebedly.
  $attributes['wmode'] = 'transparent';

  // Sort to make sure that our cache keys remain consistent - a different order
  // would change the cache key.
  ksort($attributes);
}

/**
 * Implements hook_oembed_request_element_alter().
 */
function warner_misc_oembed_request_element_alter(&$element) {
  // Force all requests to CACHE_PERMANENT.
  $element['#cache']['expire'] = CACHE_PERMANENT;
}

/**
 * Implements hook_comment_on_anything_queue_done().
 */
function warner_misc_comment_on_anything_queue_done($instance) {
  $entity_type = $instance['entity_type'];
  $site_mail = variable_get('site_mail', '');
  if (!empty($site_mail)) {
    // Send an email to the site maintainers notifying them of the rollout.
    drupal_mail('warner_misc', 'queue_notice', $site_mail, language_default(), array('entity_type' => $entity_type));
  }

  // Record a timestamp of when was the entity conversion done. This can be looked
  // up later on each site even if the mail will not land.
  variable_set('warner_misc_comment_on_anything_' . $entity_type . '_done', time());
}

/**
 * Implements hook_mail().
 */
function warner_misc_mail($key, &$message, $params) {
  global $base_url;
  if ($key == 'queue_notice') {
    $variables = array(
      '!site_name' => variable_get('site_name', $base_url),
      '!entity_type' => $params['entity_type'],
    );
    $message['subject'] = drupal_html_to_text(t('Comments node creation on !site_name complete', $variables));
    $message['body'][] = t('Nodes for comments on !entity_type type content are all created now on !site_name.', $variables);
  }
}

/**
 * Implements hook_cron().
 */
function warner_misc_cron() {
  // Clean out any old session counts that happen to live on.
  $threshold = time() - (60 * 60 * 24 * 2);
  db_delete('warner_session_count')
    ->condition('timestamp', $threshold, '<')
    ->execute();
}

/**
 * Page callback to report session counts.
 *
 * @param int $day
 *  Day of the week as in date("N").
 * @param bool $return
 *  Specify if you want the value returned, else printed as json.
 */
function warner_misc_report_session_count($day = 1, $return = FALSE) {
  // We need to suppress any errors here in order to get
  // clean json to the read script.
  ini_set('error_reporting', 0);
  ini_set('display_errors', 0);
  $dir = '/var/log/warner';
  $file = 'warner_stats_' . $day . '.log';

  $total = array();
  if (($handle = fopen($dir . '/' . $file, 'r')) !== FALSE) {
    while (($data = fgetcsv($handle, 1000, ',')) !== FALSE) {
      $total[$data[2]]['total'] += $data[3];
      $total[$data[2]][$data[1]] = $data[3];
    }
    fclose($handle);
  }

  if ($return) {
    return drupal_json_encode($total);
  }

  drupal_json_output($total);
  exit();
}

/**
 * Implements hook_modules_enabled().
 */
function warner_misc_modules_enabled($modules) {
  // Enable the gardens-flash CKEditor plugin to fix the % width bug.
  if (in_array('wysiwyg', $modules)) {
    _warner_misc_enable_gardens_wmode_plugin();
  }

  if (in_array('bunchball_nitro', $modules)) {
    warner_misc_bunchball_filter_create();
  }
}

/**
 * Create the filter format for replacing ownerID placeholders within bunchball NML.
 */
function warner_misc_bunchball_filter_create() {
  if (($filters = filter_get_filters()) && isset($filters['filter_bunchball']) && ($formats = filter_formats()) && !isset($formats['bunchball_nml'])) {
    $format = new stdClass;
    $format->format = 'bunchball_nml';
    $format->name = 'Bunchball NML';
    $format->weight = 10;
    $format->filters = array();
    $format->filters['filter_bunchball'] = array(
      'status' => 1,
      'weight' => 0,
    );
    filter_format_save($format);
    // Assign this role to site maintainers and admin for now
    $permission = filter_permission_name($format);
    if (($rid = variable_get('user_admin_role')) && $permission) {
      user_role_grant_permissions($rid, array($permission));
    }
    if (($rid = variable_get('gardens_site_owner_role', 0)) && $permission) {
      user_role_grant_permissions($rid, array($permission));
    }
  }
}

/**
 * Implements hook_views_api().
 **/
function warner_misc_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'warner_misc') . '/views',
  );
}

/**
 * Implements hook_block_info().
 */
function warner_misc_block_info() {
  $blocks['membership_stats'] = array(
    'info' => t('Membership stats'),
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function warner_misc_block_view($delta) {
  $block = array();
  if ($delta == 'membership_stats' && user_access('administer users')) {
    $block['content'] = warner_misc_membership_stats();
  }
  return $block;
}

/**
 * Returns statics about memberships on the site.
 */
function warner_misc_membership_stats() {
  // Get a count of all members.
  $member_count = db_query("SELECT COUNT(uid) FROM {users} WHERE uid > 0")->fetchField();

  // Get a count of members with the 'fan club member role'.
  $fc_role = user_role_load_by_name('fan club member');
  $fan_member_count = db_query(
    "SELECT COUNT(u.uid) FROM {users} u INNER JOIN
    {users_roles} r ON r.uid = u.uid WHERE r.rid = :rid",
    array(':rid' => $fc_role->rid)
  )->fetchField();

  // Get a count of members that registered within the last 24 hours.
  $new_member_count = db_query("SELECT COUNT(uid) FROM {users} WHERE created > :time", array(':time' => REQUEST_TIME - 86400))->fetchField();

  // Get a count of members that have never logged in.
  $inactive_member_count = db_query("SELECT COUNT(uid) FROM {users} WHERE access = 0")->fetchField();
  $vars = array(
    'member_count' => $member_count,
    'fan_member_count' => $fan_member_count,
    'new_member_count' => $new_member_count,
    'inactive_member_count' => $inactive_member_count
  );
  return theme('warner_misc_membership_stats', $vars);
}

/**
 * Theme function for the membership statistics block.
 */
function theme_warner_misc_membership_stats($variables) {
  return theme('table', array('header' => array(), 'rows' => array(
    array(t('Total members'), $variables['member_count']),
    array(t('Fan club members'), $variables['fan_member_count']),
    array(t('New members'), $variables['new_member_count']),
    array(t('Inactive members'), $variables['inactive_member_count'])
  )));
}

/**
 * Implements hook_privatemsg_block_message().
 */
function warner_misc_privatemsg_block_message($author, $recipients, $context = array()) {
  if (!warner_misc_is_privatemsg_restricted_to_friends() ) {
    return;
  }

  $blocked = array();

  foreach ($recipients as $recipient_id => $recipient) {
    // Sender or recipent is admin, skip checks.
    if (warner_misc_is_privatemsg_admin_messages_enabled() && (warner_misc_is_user_admin($author) || warner_misc_is_user_admin($recipient))) {
      continue;
    }

    // Check if sender is friend of recipent.
    if ($author->uid !== $recipient->uid) {
      $flag = flag_get_flag('friend');
      $flag_status = flag_friend_determine_friend_status($flag, $author->uid, $recipient->uid);

      if ($flag_status !== FLAG_FRIEND_FLAGGED) {
        $blocked[] = array(
          'recipient' => $recipient_id,
          'message' => t('You can only message friends.'),
        );
      }
    }
  }

  return $blocked;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adds an option to restrict messaging to friends only.
 */
function warner_misc_form_privatemsg_admin_settings_alter(&$form, $form_state) {
  if (!module_exists('flag_friend')) {
    return;
  }

  $form['flag_friend'] = array(
    '#type' => 'fieldset',
    '#group' => 'settings',
    '#title' => t('Flag friend integration'),
  );

  $form['flag_friend']['privatemsg_restrict_messaging_to_friends_only'] = array(
    '#type' => 'checkbox',
    '#title' => t('Restrict messaging to friends only'),
    '#description' => t(''),
    '#default_value' => warner_misc_is_privatemsg_restricted_to_friends(),
  );

  $form['flag_friend']['privatemsg_allow_admin_messages'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow messages from/to admins'),
    '#description' => t(''),
    '#default_value' => warner_misc_is_privatemsg_admin_messages_enabled(),
    '#states' => array(
      'invisible' => array(
        ':input[name=privatemsg_restrict_messaging_to_friends_only]' => array('checked' => FALSE),
      ),
    ),
  );
}

/**
 * Helper function to check if private messages is restricted to friends only.
 *
 * @return Bool
 *   TRUE if Private messages is restricted to friends only.
 */
function warner_misc_is_privatemsg_restricted_to_friends() {
  $flag_friend_enabled = module_exists('flag_friend');
  $privatemsg_restricted = variable_get('privatemsg_restrict_messaging_to_friends_only', FALSE);

  return $flag_friend_enabled && $privatemsg_restricted;
}

/**
 * Helper function to check if admin messaging is allowed.
 *
 * @return Bool
 *   TRUE if admin messaging is enabled.
 */
function warner_misc_is_privatemsg_admin_messages_enabled() {
  $allow_admin_messages = variable_get('privatemsg_allow_admin_messages', TRUE);

  return $allow_admin_messages;
}


/**
 * Helper function to determine if the user is an admin.
 *
 * @return Bool
 *   TRUE if the user is an admin.
 */
function warner_misc_is_user_admin($account) {
  $admin_role = variable_get('user_admin_role');
  if ($admin_role) {
    return array_key_exists($admin_role, $account->roles);
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function warner_misc_form_node_type_form_alter(&$form, $form_state) {
  if (module_exists('scheduler')) {
    _warner_misc_scheduler_attach_js_vertical_tabs($form['scheduler']);
    $form['scheduler']['publish']['advanced']['scheduler_publish_past_date']['#default_value'] = variable_get('scheduler_publish_past_date_' . $form['#node_type']->type, 'publish');
    $form['scheduler']['publish']['advanced']['#access'] = FALSE;

    // Use different default value for certain CTs.
    // See https://backlog.acquia.com/browse/DG-9383#comment-217332.
    $default_value_default_scheduler_publish_touch = in_array($form['#node_type']->type, array(
      'photo',
      'video',
      'blog',
      'splash_page'
    )) ? 1 : 0;
    $form['scheduler']['publish']['scheduler_publish_touch']['#default_value'] = variable_get('scheduler_publish_touch_' . $form['#node_type']->type, $default_value_default_scheduler_publish_touch);
  }
}

/**
 * Implements hook_form_alter().
 */
function warner_misc_form_alter(&$form, $form_state) {
  if (!empty($form['#node_edit_form']) && module_exists('scheduler') && user_access('schedule (un)publishing of nodes')) {
    $publishing_enabled = variable_get('scheduler_publish_enable_' . $form['type']['#value'], 0) == 1;
    $unpublishing_enabled = variable_get('scheduler_unpublish_enable_' . $form['type']['#value'], 0) == 1;

    // if scheduling has been enabled for this node type
    if ($publishing_enabled || $unpublishing_enabled) {
      _warner_misc_scheduler_attach_js_vertical_tabs($form['scheduler_settings']);

      $user_timezone = drupal_get_user_timezone();
      $timezone = new DateTimeZone($user_timezone);
      $now = new DateTime("now", $timezone);
      $user_timezone_abbreviation = $now->format('T');
      $user_timezone_offset = $now->format('O');

      $settings = array(
        'userTimezoneName' => $user_timezone,
        'userTimezoneAbbr' => $user_timezone_abbreviation,
        'userTimezoneOffset' => $user_timezone_offset,
      );
      drupal_add_js(array('warnerMiscScheduler' => $settings), 'setting');
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function warner_misc_form_migrate_ui_configure_form_alter(&$form, $form_state, $form_id) {
  // Provide Warner the option of setting all
  $form['metatag_dnm'] = array(
    '#type' => 'fieldset',
    '#title' => t('Metatag fields'),
    '#description' => t('Sets the DNM flag on all metatag fields in all migrations'),
  );

  $form['metatag_dnm']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Set all metatag fields DNM'),
    '#submit' => array('warner_misc_metatag_dnm_submit'),
  );
}

/**
 * Submit callback for the metatag field mappings.
 */
function warner_misc_metatag_dnm_submit($form, &$form_state) {
  // Set all migration source and destination fields for the metatag module
  // to DNM (unmapped).
  /**
   * @var Migration $migration
   */
  foreach (migrate_migrations() as $machine_name => $migration) {
    $destination = $migration->getDestination();
    foreach ($destination->fields($migration) as $field_name => $description) {
      if (!strncmp('metatag', $field_name, 7)) {
        $mapping = new MigrateFieldMapping($field_name, NULL, FALSE);
        $mapping->issueGroup(t('DNM'));
        db_merge('migrate_field_mapping')
          ->key(array(
              'machine_name' => $machine_name,
              'destination_field' => $field_name,
            ))
          ->fields(array(
              'source_field' => '',
              'options' => serialize($mapping),
            ))
          ->execute();
      }
    }
    $source = $migration->getSource();
    foreach ($source->fields($migration) as $field_name => $description) {
      if (!strncmp('metatag', $field_name, 7)) {
        $mapping = new MigrateFieldMapping(NULL, $field_name, FALSE);
        $mapping->issueGroup(t('DNM'));
        db_merge('migrate_field_mapping')
          ->key(array(
              'machine_name' => $machine_name,
              'source_field' => $field_name,
            ))
          ->fields(array(
              'destination_field' => '',
              'options' => serialize($mapping),
            ))
          ->execute();
      }
    }
  }
  drupal_set_message(t('Metatag fields set to DNM'));
  $form_state['redirect'] = 'admin/content/migrate';
}

/**
 * Attach the overridden scheduler vertical tabs javascript.
 *
 * @param $element
 *   The form element to which the javascript should be attached.
 */
function _warner_misc_scheduler_attach_js_vertical_tabs(&$element) {
  $element['#attached']['js']['vertical-tabs'] = drupal_get_path('module', 'warner_misc') . "/js/warner_misc_scheduler_vertical_tabs.js";
}

/**
 * Implements hook_simplified_modules_hidden_dependencies_alter().
 */
function warner_misc_simplified_modules_hidden_dependencies_alter(&$modules) {
  // Modules that are hidden by default but should be allowed here.
  $modules = array_diff($modules, array(
    'migrate',
    'migrate_ui',
    'migrate_extras',
  ));
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Extend the Bakery module settings form with options for additional fields
 * to transfer to slave sites.
 */
function warner_misc_form_bakery_settings_alter(&$form, $form_state) {
  $profile_fields = field_info_instances('user');
  $options = array();

  foreach ($profile_fields['user'] as $field_name => $field) {
    $options[$field_name] = check_plain($field['label']);
  }

  $form['bakery_transfer_uid'] = array(
    '#type' => 'checkbox',
    '#title' => 'Transfer user ID?',
    '#default_value' => variable_get('bakery_transfer_uid', FALSE),
    '#description' => t('Include UID in the response when a slave site requests account data from the master site.'),
  );

  $form['bakery_transfer_roles'] = array(
    '#type' => 'checkbox',
    '#title' => 'Transfer user roles?',
    '#default_value' => variable_get('bakery_transfer_roles', FALSE),
    '#description' => t('Include user roles in the response when a slave site requests account data from the master site.'),
  );

  $form['bakery_extra_supported_fields'] = array(
    '#type' => 'checkboxes',
    '#title' => 'Additional profile fields',
    '#default_value' => variable_get('bakery_extra_supported_fields', array()),
    '#options' => $options,
    '#description' => t('Include these fields in the response when a slave site requests account data from the master site.'),
  );
}

/**
 * Get an array of fields to transmit via Bakery.
 */
function _warner_misc_bakery_get_fields_to_transmit() {
  $user_fields = variable_get('bakery_extra_supported_fields');
  $user_fields = array_filter($user_fields);
  return $user_fields;
}

/**
 * Implements hook_bakery_transmit().
 *
 * Add uid, roles and additional profile fields data.
 */
function warner_misc_bakery_transmit($edit, $account, $category) {
  // Execute only if account data is requested, but not when saving profile.
  if (!empty($edit)) {
    return array();
  }

  $data = array();
  $fields_to_transmit = _warner_misc_bakery_get_fields_to_transmit();
  $wrapper = entity_metadata_wrapper('user', $account);

  // Add fields, metadata wrapper will handle multiple values.
  foreach ($fields_to_transmit as $field) {
    $data['fields'][$field] = $wrapper->{$field}->raw();
  }

  // Add uid if needed.
  $transfer_uid = variable_get('bakery_transfer_uid', FALSE);
  if (!empty($transfer_uid)) {
    $data['uid'] = $account->uid;
  }

  // Add roles if needed.
  $transfer_roles = variable_get('bakery_transfer_roles', FALSE);
  if (!empty($transfer_roles)) {
    $data['roles'] = $account->roles;
  }

  return $data;
}

/**
 * Implements hook_element_info_alter().
 */
function warner_misc_element_info_alter(&$types) {
  // Check if WYSIWYG is enabled before altering.
  if (module_exists('wysiwyg')) {
    $types['text_format']['#pre_render'][] = 'warner_misc_pre_render_text_format';
  }
}

/**
 * This function alters WYSIWYG text inputs to improve UX.
 */
function warner_misc_pre_render_text_format($element) {
  global $wysiwyg_comment;

  // Make sure this is a comment form. Check again and do not exclude
  // comment forms on forums. See gardens_misc_pre_render_text_format().
  if (isset($element['#entity_type']) && isset($element['#bundle']) && $element['#entity_type'] == 'comment') {
    $wysiwyg_comment = TRUE;
  }

  return $element;
}

/**
 * Implements hook_wysiwyg_editor_settings_alter().
 *
 * Update toolbar with the allowed buttons.
 */
function warner_misc_wysiwyg_editor_settings_alter(&$settings, &$context) {
  // Check to see if we're creating an instance of the WYSIWYG
  // for a comment form.
  global $wysiwyg_comment;
  // If this is a comment form.
  if ($wysiwyg_comment) {
    // Setup our new toolbar.
    $new_toolbar = array();
    // Get allowed buttons for selected input format.
    $comment_allowed_buttons = variable_get('warner_misc_comment_form_buttons_for_' . $context['profile']->format, array());

    // Add them to the toolbar.
    if (!empty($comment_allowed_buttons)) {
      foreach ($comment_allowed_buttons as $button => $value) {
        $new_toolbar[0][] = $button;
      }
    }

    $settings['toolbar'] = $new_toolbar;
  }
}

/**
 * Implements hook_required_modules_alter().
 */
function warner_misc_required_modules_alter(&$modules) {
  $modules = array_diff($modules, array(
    // Allow 'media_youtube' to be disabled.
    'media_youtube',
  ));
}
