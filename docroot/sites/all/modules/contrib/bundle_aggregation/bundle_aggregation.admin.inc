<?php

/**
 * @file
 * Admin UI-related functions for the Bundle Aggregation module.
 */

/**
 * Bundle aggregation admin settings form.
 */
function bundle_aggregation_admin_settings() {
  $form = array();
  $form['bundle_aggregation_enabled'] = array(
    '#title' => t('Bundle aggregation status'),
    '#description' => t('While inactive the module is not going to interfere with CSS / JS files, so any existing aggregation may work on its own. This allows the administrator to configure the module. Privileged users will be still able to use the aggregation by visiting the pages with the GET parameter bundle_aggregation to test it out and queue up bundles for generation so when the module is enabled the visitors are not being offered tons of JS / CSS includes. Even if this module is active, bundling will not occur if the site is not configured to !aggregate, or in !maintenance.', array(
      '!aggregate' => l(t('aggregate CSS and/or JS files'), 'admin/config/development/performance', array('attributes' => array('title' => t('Enable or disable page caching for anonymous users and set CSS and JS bandwidth optimization options.')))),
      '!maintenance' => l(t('maintenance mode'), 'admin/config/development/maintenance', array('attributes' => array('title' => t('Take the site offline for maintenance or bring it back online.')))),
     )),
    '#type' => 'checkbox',
    '#options' => array(
      0 => t('Inactive'),
      1 => t('Active'),
    ),
    '#default_value' => (int) variable_get('bundle_aggregation_enabled', FALSE),
  );

  $form['bundle_version'] = array(
    '#title' => t('Bundle version numbering'),
    '#type' => 'fieldset',
  );
  $form['bundle_version']['drupal_css_cache_version'] = array(
    '#title' => t('CSS bundle version'),
    '#description' => t('This number represents the version of the CSS bundles. Up this number if every CSS bundle needs to be regenerated.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('drupal_css_cache_version', 1),
    '#element_validate' => array('element_validate_integer_positive'),
  );
  $form['bundle_version']['drupal_js_cache_version'] = array(
    '#title' => t('JS bundle version'),
    '#description' => t('This number represents the version of the JS bundles. Up this number if every JS bundle needs to be regenerated.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('drupal_js_cache_version', 1),
    '#element_validate' => array('element_validate_integer_positive'),
  );

  $form['hierarchic_caching'] = array(
    '#title' => t('Hierarchic caching'),
    '#type' => 'fieldset',
  );
  $form['hierarchic_caching']['bundle_aggregation_hierarchic_caching'] = array(
    '#title' => t('Hierarchic caching status'),
    '#description' => t('High traffic sites with multiple webheads might have issues with the internal traffic generated by frequently used cache requests. If the hierarchic cache support is enabled bundle changes are being stored in a cache to signal the webheads to refresh the local cache. Assign the cache_bundle_aggregation bin to a local cache instance, assign the cache_bundle_aggregation_locks to a global cache instance.'),
    '#type' => 'checkbox',
    '#options' => array(
      0 => t('Disabled'),
      1 => t('Enabled'),
    ),
    '#default_value' => variable_get('bundle_aggregation_hierarchic_caching', FALSE),
    '#access' => user_access('administer bundle aggregation technical settings'),
  );
  $form['hierarchic_caching']['bundle_aggregation_hierarchic_cache_ttl'] = array(
    '#title' => t('Hierarchic cache TTL'),
    '#description' => t('When hierarchic caching is enabled the cache items will live for this many seconds, after that they will be refetched from the database.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('bundle_aggregation_hierarchic_cache_ttl', 86400),
    '#element_validate' => array('element_validate_integer_positive'),
    '#access' => user_access('administer bundle aggregation technical settings'),
  );

  $form['queue_settings'] = array(
    '#title' => t('Queue settings'),
    '#type' => 'fieldset',
  );
  $form['queue_settings']['bundle_aggregation_rebuild_time'] = array(
    '#title' => t('Bundle processing time'),
    '#description' => t('Number of seconds a bundle aggregation should finish. This value is used for the queue processing and also for the locking mechanism to avoid bundle generation request flood.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('bundle_aggregation_rebuild_time', 60),
    '#element_validate' => array('element_validate_integer_positive'),
    '#access' => user_access('administer bundle aggregation technical settings'),
  );
  $form['queue_settings']['bundle_aggregation_bundle_grace_period'] = array(
    '#title' => t('Unused bundle grace period'),
    '#description' => t('Specify the number of seconds after which an unused bundle should be deleted from the server.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('bundle_aggregation_bundle_grace_period', 86400),
    '#element_validate' => array('element_validate_integer_positive'),
    '#access' => user_access('administer bundle aggregation technical settings'),
  );
  $form['queue_settings']['bundle_aggregation_bundle_cleanup_limit'] = array(
    '#title' => t('Bundle cleanup batch size'),
    '#description' => t('Specify the number of bundles to be removed on a cron run.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('bundle_aggregation_bundle_cleanup_limit', 20),
    '#element_validate' => array('element_validate_integer_positive'),
    '#access' => user_access('administer bundle aggregation technical settings'),
  );

/*
  $options = array();
  $allowed_css_key_fragments = variable_get('bundle_aggregation_css_key_fragments', NULL);
  $form['css_key_fragments'] = array(
    '#title' => t('CSS bundle key fragments'),
    '#description' => t('The bundles are being keyed by these fragments. If you want to have a more generalised bundle you can uncheck some or all of these.'),
    '#type' => 'checkboxes',
    '#options' => bundle_aggregation_available_css_key_fragments_get(),
    '#default_value' => isset($allowed_css_key_fragments) ? $allowed_css_key_fragments : array_keys(bundle_aggregation_available_css_key_fragments_get()),
    '#access' => FALSE && user_access('administer bundle aggregation technical settings'), // Bundle key fragment tweaking will need more love before it can be enabled.
  );
  $allowed_js_key_fragments = variable_get('bundle_aggregation_js_key_fragments', NULL);
  $form['js_key_fragments'] = array(
    '#title' => t('JS bundle key fragments'),
    '#description' => t('The bundles are being keyed by these fragments. If you want to have a more generalised bundle you can uncheck some or all of these.'),
    '#type' => 'checkboxes',
    '#options' => bundle_aggregation_available_js_key_fragments_get(),
    '#default_value' => isset($allowed_js_key_fragments) ? $allowed_js_key_fragments : array_keys(bundle_aggregation_available_js_key_fragments_get()),
    '#access' => FALSE && user_access('administer bundle aggregation technical settings'), // Bundle key fragment tweaking will need more love before it can be enabled.
  );
*/

  return system_settings_form($form);
}

/**
 * View and modify aggregated bundles.
 */
function bundle_aggregation_admin_bundle_handling() {
  $build = array();
  $build['remove'] = drupal_get_form('bundle_aggregation_admin_bundle_file_removal_form');
  $build['listing'] = drupal_get_form('bundle_aggregation_admin_bundle_listing');
  return $build;
}

/**
 * Generates a bundle listing page.
 */
function bundle_aggregation_admin_bundle_listing($form, $form_state) {
  $form = array();

  $path_search = isset($_GET['path_search']) ? trim($_GET['path_search']) : '';
  $form['path_search'] = array(
    '#title' => t('Bundle lookup by path'),
    '#description' => t('Provide full path to bundle to be found or the first few letters of the filename.'),
    '#type' => 'textfield',
    '#default_value' => $path_search,
    '#maxlength' => 255,
  );
  $form['search'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );
  $form['reset'] = array(
    '#type' => 'submit',
    '#value' => t('Reset'),
    '#submit' => array('bundle_aggregation_admin_bundle_listing_reset_search'),
  );

  $header = array(
    array(
      'data' => t('Bundle ID'),
      'field' => 'bundle_id',
      'sort' => 'asc', // Default sort.
    ),
    array(
      'data' => t('Bundle type'),
    ),
    array(
      'data' => t('Path'),
      'field' => 'path',
    ),
    array(
      'data' => t('Bundle version'),
    ),
    array(
      'data' => t('Files'),
    ),
  );

  // bundle_aggregation_bundle_load($bundle_key)
  $query = db_select('bundle_aggregation_bundles', 'b')
    ->fields('b', array('bundle_id', 'bundle_type', 'path', 'bundle_version', 'files'))
    ->extend('PagerDefault')->limit(50)
    ->extend('TableSort')->orderByHeader($header);
  if ($path_search) {
    // Path could contain full path or just a filename. The query is searching
    // for bundles using a public://[css|js]/filename prefix. By stripping
    // everything in front of 'css/' or 'js/' and after '.css' or '.js' we'll
    // get a filename.
    $css_start = strpos($path_search, 'css/');
    $js_start = strpos($path_search, 'js/');
    if ($css_start !== FALSE) {
      $path_search = drupal_substr($path_search, $css_start + 4);
    }
    elseif ($js_start !== FALSE) {
      $path_search = drupal_substr($path_search, $js_start + 3);
    }
    $css_end = strpos($path_search, '.css');
    $js_end = strpos($path_search, '.js');
    if ($css_end !== FALSE) {
      $path_search = drupal_substr($path_search, 0, $css_end + 4);
    }
    elseif ($js_end !== FALSE) {
      $path_search = drupal_substr($path_search, 0, $js_end + 3);
    }
    // Extend filename to look like public://[css|js]/filename.
    if (drupal_substr($path_search, 0, 1) == 'c') {
      $path_search = 'public://css/' . $path_search;
    }
    else {
      $path_search = 'public://js/' . $path_search;
    }
    $query->condition('b.path',  db_like($path_search) . '%', 'LIKE');
  }
  $rs = $query->execute();

  $rows = array();
  foreach ($rs as $row) {
    $files = unserialize($row->files);
    $rows[] = array(
      'data' => array(
        l($row->bundle_id, 'admin/config/development/bundle-aggregation/bundles/' . $row->bundle_id),
        strtoupper(bundle_aggregation_pretty_bundle_type($row->bundle_type)),
        $row->path,
        $row->bundle_version,
        is_array($files) ? count($files) : 0,
      ),
    );
  }

  $form['table'] = array(
    '#theme' => 'table__bundle_aggregation',
    '#header' => $header,
    '#rows' => $rows,
    '#sticky' => TRUE,
    '#empty' => t('No bundle found.'),
  );
  $form['pager'] = array(
    '#theme' => 'pager__bundle_aggregation',
    '#tags' => array(),
  );

  return $form;
}

/**
 * Bundle search form submit handler - preserve submit values.
 */
function bundle_aggregation_admin_bundle_listing_submit($form, &$form_state) {
  $form_state['redirect'] = array(
    $_GET['q'],
    array('query' => array('path_search' => trim($form_state['values']['path_search']))),
  );
}

/**
 * Bundle search form submit handler - reset search.
 */
function bundle_aggregation_admin_bundle_listing_reset_search($form, &$form_state) {
  $form_state['redirect'] = $_GET['q'];
}

/**
 * Outputs the bundle items form as a table.
 */
function theme_bundle_aggregation_admin_bundle_form($variables) {
  $form = $variables['form'];

  $header = array(
    array('data' => t('File')),
    array('data' => t('Weight')),
    array('data' => t('Remove')),
  );

  $rows = array();
  foreach (element_children($form) as $key) {
    // Generate table rows.
    if ($key == 'rows') {
      foreach (element_children($form['rows']) as $row) {
        // Tabledrag requires the weight form items to be "grouped" using a
        // custom CSS class selector.
        $form['rows'][$row]['weight']['#attributes']['class'][] = 'bundle-weight';

        $rows[] = array(
          'data' => array(
            drupal_render($form['rows'][$row]['file']),
            drupal_render($form['rows'][$row]['weight']),
            drupal_render($form['rows'][$row]['remove']),
          ),
          'class' => array('draggable'),

          // Sets the weight of the row to match the current weight value of the
          // form select field.
          '#weight' => $form['rows'][$row]['weight']['#default_value'],
        );
      }
    }
    // Add the remaining form items to the output.
    else {
      $form_fields[$key] = $form[$key];
    }
  }

  // Add tabledrag support.
  drupal_add_tabledrag('bundle-aggregation-bundle', 'order', 'sibling', 'bundle-weight');

  // Sort the rows by #weight.
  uasort($rows, 'element_sort');

  $content = array(
    'table' => array(
      '#theme' => 'table__bundle_aggregation_bundle',
      '#header' => $header,
      '#rows' => $rows,
      '#attributes' => array('id' => 'bundle-aggregation-bundle'),
      '#sticky' => TRUE,
      '#empty' => t('No files exist in this bundle.'),
    ),
    'form' => $form_fields,
  );

  return render($content);
}

/**
 * Generates a form to set the weight of bundle items.
 */
function bundle_aggregation_admin_bundle_form($form, &$form_state, $bundle_data) {
  $form['#theme'] = 'bundle_aggregation_admin_bundle_form';
  $form['#tree'] = TRUE;

  $count = count($bundle_data['files']);

  $form['rows'] = array();
  foreach ($bundle_data['files'] as $file => $weight) {
    $form['rows'][$file]['weight'] = array(
      '#type' => 'weight',
      '#default_value' => $weight,
      '#attributes' => array('class' => array('weight')),
      '#delta' => max(10, $count),
    );
    $form['rows'][$file]['file'] = array(
      '#markup' => $file,
    );
    $form['rows'][$file]['remove'] = array(
      '#type' => 'checkbox',
      '#default_value' => 0,
    );
  }

  $form['bundle_id'] = array(
    '#type' => 'value',
    '#value' => $bundle_data['bundle_id'],
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 100,
  );

  return $form;
}

/**
 * Submit handler for the bundle items form.
 *
 * Allows the order of items to be adjusted and items to be removed from
 * bundles.
 *
 * @see bundle_aggregation_admin_bundle_form()
 */
function bundle_aggregation_admin_bundle_form_submit($form, &$form_state) {
  if ($bundle_data = bundle_aggregation_bundle_load($form_state['values']['bundle_id'])) {
    $removed_files = array();
    $reordered_files = array();

    foreach ($form_state['values']['rows'] as $path => $value) {
      if ($value['remove']) {
        $removed_files[] = $path;
      }
      elseif ($bundle_data['files'][$path] != $value['weight']) {
        $reordered_files[$path] = $value['weight'];
      }
    }

    // We are not doing bundle rebuilding here to avoid possible conflicts with
    // an existing rebuilding running on queue processing. Not saving the data
    // into the database either, because the lack of regeneration and possible
    // hierarchical caches could cause enough confusion.
    $rebuild_info = array(
      'bundle_type' => $bundle_data['bundle_type'],
      'bundle_key' => $bundle_data['bundle_id'],
      'force_rebuild' => 1,
      'removed_files' => $removed_files,
      'reordered_files' => $reordered_files,
    );
    DrupalQueue::get('bundle_aggregation_bundle_rebuilding')->createItem($rebuild_info);
    drupal_set_message(t('The bundle has been queued for rebuilding, your changes will be applied when it finishes.'));
  }
}

/**
 * File removal from bundles - form builder.
 */
function bundle_aggregation_admin_bundle_file_removal_form($form, $form_state) {
  $form = array();
  $form['files'] = array(
    '#type' => 'textarea',
    '#title' => t('Files to be removed'),
    '#description' => t('List one file per line to be removed from the bundles. The entries do not have to be full paths, even partial matches will mark files for removal.'),
    '#default_value' => isset($form_state['values']['files']) ? $form_state['values']['files'] : '',
    '#required' => TRUE,
  );
  $form['remove'] = array(
    '#type' => 'submit',
    '#value' => t('Remove'),
  );
  return $form;
}

/**
 * File removal form from bundles - submit handler.
 */
function bundle_aggregation_admin_bundle_file_removal_form_validate($form, $form_state) {
  if (!trim($form_state['values']['files'])) {
    form_set_error('files', t('Please enter some file path fragments.'));
  }
}

/**
 * File removal form from bundles - submit handler.
 */
function bundle_aggregation_admin_bundle_file_removal_form_submit($form, &$form_state) {
  // To keep the 'files' intact in the form.
  $form_state['rebuild'] = TRUE;
  // This variable will indicate if at least one bundle has been requeued. If
  // not then we will set a dsm just so the user gets the info.
  $affected_bundle_found = FALSE;
  // Get the list of files to be removed.
  $files_to_remove = array_filter(array_map('trim', explode("\n", $form_state['values']['files'])));
  $rs = db_query('SELECT bundle_id, bundle_type, files FROM {bundle_aggregation_bundles}');
  foreach ($rs as $row) {
    $paths_to_remove = array();
    $current_files = unserialize($row->files);
    foreach ($files_to_remove as $file_to_remove) {
      foreach ($current_files as $path => $weight) {
        if (strpos($path, $file_to_remove) !== FALSE) {
          $paths_to_remove[] = $path;
        }
      }
    }
    if ($paths_to_remove) {
      $affected_bundle_found = TRUE;
      $rebuild_info = array(
        'bundle_type' => $row->bundle_type,
        'bundle_key' => $row->bundle_id,
        'force_rebuild' => 1,
        'removed_files' => $paths_to_remove,
        'reordered_files' => array(),
      );
      DrupalQueue::get('bundle_aggregation_bundle_rebuilding')->createItem($rebuild_info);
      drupal_set_message(t('@bundle_id has been queued up to be regenerated without the following files: @files.', array('@bundle_id' => $row->bundle_id, '@files' => implode(', ', $paths_to_remove))));
    }
  }
  if (!$affected_bundle_found) {
    drupal_set_message(t('None of the bundles contain any files that would match the entered list.'));
  }
}
