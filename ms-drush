#!/usr/bin/env php
<?php
/**
 * @file: Multi-site wrapper for drush commands
 */

require_once('library/acquia_gardens_xmlrpc.inc');

// We only run this script by hand - make sure we see any errors.
ini_set('display_startup_errors', 1);
ini_set('display_errors', 1);


$args = drush_gardens_args();

$argv_orig = $_SERVER['argv'];
if (count($_SERVER['argv']) > 1) {
  $ret = getopt_long($args);
  if ($ret !== $_SERVER['argc']-1) {
    usage();
  }
}
else {
  usage();
}

$current_directory = dirname(__FILE__);
$files = "$current_directory/docroot/files/ms-drush";

if ($args['prepare']) {
  drush_gardens_prepare($args);
}
elseif ($args['cleanup']) {
  // Using system() to call  rm -rf was failing silently in some cases.
  // The native PHP functions seem more reliable.
  foreach (glob("$files/*") as $f) {
    echo "Deleting: $f\n";
    unlink($f);
  }
  exit;
}

if (!file_exists("$files/active_domains_by_site.json.txt") || !file_exists("$files/aliases.drushrc.php")) {
  echo "You must use --prepare first\n";
  exit(1);
}

$wrapper_script = dirname(__FILE__) . '/drush-ms-wrapper.rb';
if ($args['dc'] && !file_exists($wrapper_script)) {
  echo "ERROR: drush-ms-wrapper.rb must be in same directory as this script.\n";
  exit(1);
}

// Shortcut alias
if ($args['full-update']) {
  $args['dc'] = array_merge(array('root: go-offline', 'root: move-gsite-domains', 'updatedb', 'always: root: go-online'), $args['dc']);
}

// This hosting drush command only runs once, not for each site.
if ($args['move-domains-to-staging']) {
  $cmd = "drush/drush move-domains-to-staging -i $current_directory/hosting-drush -r $current_directory/docroot -l http://default";
  if ($args['verbose']) {
    echo "$cmd\n";
  }
  system($cmd);
  exit;
}

// This hosting drush command only runs once, not for each site.
if ($args['move-domains-to-production']) {
  $cmd = "drush/drush move-domains-to-production -i $current_directory/hosting-drush -r $current_directory/docroot -l http://default";
  if ($args['verbose']) {
    echo "$cmd\n";
  }
  system($cmd);
  exit;
}

if (!$args['dc']) {
  exit;
}

$sites = array();

include "$files/aliases.drushrc.php";
$all_sites = array_keys($aliases);

if ($args['onesite']) {
  $sites[] = $args['onesite'];
}
elseif ($args['first']) {
  $sites = array_slice($all_sites, 0, $args['first']);
}
elseif ($args['from']) {
  // The first site is #0.
  $length = NULL;
  if ($args['from'] > 0) {
    if ($args['to'] > 0) {
      $length = $args['to'] - $args['from'] + 1;
    }
  }
  $sites = array_slice($all_sites, $args['from'], $length);
}
elseif ($args['all']) {
  $sites = $all_sites;
  // basethemes.drupalgardens.com (g351) is used as a shared fallback site for
  // the Gardens Varnish cache. This can lead to a problem during Gardens
  // updates if the basethemes site hasn't been updated yet but other sites
  // have. In particular, those sites may try to load images that are in the
  // new codebase but not the old one, so the server won't find the image when
  // it looks for it in the (un-updated) basethemes site. To prevent this, the
  // code below ensures that when we are running a Drush command on all Gardens
  // sites, it always runs on the basethemes site first (if that site is
  // available).
  //
  // Note: The opposite problem from what is described above (e.g., an image
  // that was in the old codebase but not in the new one) is less likely to be
  // an issue since items remain in the Varnish cache for two weeks. Therefore,
  // the old image will likely still be available in the cache, and the
  // basethemes site won't be queried for it.
  $key = array_search('g351', $sites);
  if ($key !== FALSE) {
    $basethemes_site = $sites[$key];
    unset($sites[$key]);
    array_unshift($sites, $basethemes_site);
  }
}

if (empty($sites)) {
  echo "No sites. Need to correctly specify --onesite <gNNN>, --first <N>, --from <N> [--to <N>], or --all\n";
  exit(1);
}

$log = "{$args['log-dir']}/{$args['log-prefix']}";

// For some reason xargs -n1 doesn't work alone.
$cmd = "echo ". implode(' ', $sites) ." | xargs -n1 | xargs  -P{$args['procs']} -I{} {$wrapper_script} --site={} --log {$log}";

if ($args['dry-run']) {
  $cmd .= " --dry-run";
}

if ($args['nice']) {
  $cmd .= " --nice";
}

if($args['verbose']) {
  $cmd .= ' -v';
}

foreach($args['dc'] as $command) {
  $cmd .= ' --dc ' . escapeshellarg($command);
}

echo "Log files available at {$args['log-dir']}/{$args['log-prefix']}.*.log\n";

if ($args['verbose']) {
  echo "$cmd\n";
}

$start = time();
shell_exec($cmd);
$stop = time();
if (empty($args['dry-run'])) {
  report_on_log($args['log-dir'], $args['log-prefix'], $start, $stop) ;
}

exit;

/**
 * Utility and helper functions
 */


function report_on_log($log_dir, $log_prefix, $start, $stop) {
  $statuses = array('success' => array(), 'not_ready' => array(), 'error' => array());
  $count = 0;
  $fp = @fopen("$log_dir/$log_prefix.log", 'r');
  if (!$fp) {
    return;
  }

  while (($row = fgetcsv($fp)) !== FALSE) {
    $s = $row[2];
    $statuses[$s][] = $row[1];
    $count += 1;
  }
  fclose($fp);
  echo "

Results:
-----------------------
Sites processed: {$count}
Start time: {$start}
Finish time: {$stop}

Successful (". count($statuses['success']) .")

Not Attempted (" . count($statuses['not_ready']). ")\n" . implode("\n", $statuses['not_ready']) . "

Errors (" . count($statuses['error']). ")\n"  . implode("\n", $statuses['error']) . "

Error Log available at {$log_dir}/{$log_prefix}.error.log\n";

}

function drush_gardens_prepare($args) {
  if (!is_dir($args['log-dir'])) {
    mkdir($args['log-dir'], 0755, TRUE);
  }
  $current_directory = dirname(__FILE__);
  $files = "$current_directory/docroot/files/ms-drush";
  if (!is_dir($files)) {
    mkdir($files, 0755, TRUE);
  }
  if (file_exists("$files/active_domains_by_site.json.txt") || file_exists("$files/aliases.drushrc.php")) {
    throw new Exception("The prep files already exist, did you forget to clean up?\n$files/active_domains_by_site.json.txt\n$files/aliases.drushrc.php\n");
  }

  // Rely on the fact that Hosting sites are installed in directories given by
  // their site name.
  $hosting_site_name = basename($current_directory);
  // Assuming allow_url_fopen as On to get remote files.
  $active_domains = acquia_gardens_call('get.active.domains.by.site', array($hosting_site_name));
  $json = json_encode($active_domains);
  // @todo: Fix this code, for now it is simulating how the old code worked that grabbed the text file to minimize interruption.

  //$json = file_get_contents(_acquia_gardens_xmlrpc_server() ."/files/gardens/$hosting_site_name/active_domains_by_site.json.txt");
  if (empty($json)) {
    throw new Exception("Did not retrieve any data for active_domains_by_site.");
  }
  file_put_contents("$files/active_domains_by_site.json.txt", $json);
  $site_domains = json_decode($json);
  $aliases = array();
  $root = realpath("$current_directory/docroot");
  foreach ($site_domains as $gardens_site_id => $domains) {
    $domain = $args['use-gardens-domains'] ? reset($domains) : end($domains);
    $aliases[$gardens_site_id] = array(
      'root' => $root,
      'uri' => 'http://' . $domain,
      '#name' => $gardens_site_id,
    );
  }
  uksort($aliases, 'gardens_id_compare');
  file_put_contents("$files/aliases.drushrc.php", "<?php\n\$aliases = " . var_export($aliases, TRUE) . ";\n");
}

function gardens_id_compare($k1, $k2) {
  // We want to sort from highest to lowest nid.
  return intval(substr($k2, 1)) - intval(substr($k1, 1));
}

/**
 * Parse arguments from $_SERVER['argv'].  TODO: We have other
 * implementations of this lying around...
 *
 * @param $args
 *   TODO: document.  Modified in place.
 * @return
 *   Number of arguments parsed, or FALSE on error.  $args is modified in place.
 */
function getopt_long(&$args) {
  // Override with set values.
  $args['script'] = basename(array_shift($_SERVER['argv']));

  $count = 0;
  while ($arg = array_shift($_SERVER['argv'])) {
    if (preg_match('/--(\S+)/', $arg, $matches)) {
      // Argument found.
      if (array_key_exists($matches[1], $args)) {
        // Argument found in list.
        $previous_arg = $matches[1];
        if (is_bool($args[$previous_arg])) {
          $args[$matches[1]] = TRUE;
        }
        else if (is_array($args[$previous_arg])) {
          $args[$previous_arg][] = array_shift($_SERVER['argv']);
          $count++;
        }
        else {
          $args[$matches[1]] = array_shift($_SERVER['argv']);
          $count++;
        }
        $count++;
      }
      else {
        // Argument not found in list.
        fwrite (STDERR, "Unknown argument '$arg'\n");
        return FALSE;
      }
    }
    else {
      // Stop processing on non-"--" argument
      array_unshift($_SERVER['argv'], $arg);
      break;
    }
  }

  return $count;
}

/**
 * Ensure required arguments are provided, exit with usage info if
 * they are not.
 *
 * @param $args
 *   The provided arguments.
 * @param $required
 *   An array of arguments that must be non-empty.
 * @return
 *   Nothing, or terminates with a usage message on stderr.
 */
function require_args($args, $required) {
  foreach ($required as $key) {
    if (empty($args[$key]) && (!is_string($args[$key]) || $args[$key] === '') && !is_int($args[$key])) {
      usage("ERROR: --$key argument is required");
      exit(1);
    }
  }
}

function drush_gardens_args() {
  static $date;
  if (empty($date)) {
    $date = date('Y-m-d_His');
  }
  return array(
    'prepare' => FALSE,
    'use-gardens-domains' => FALSE,
    'move-domains-to-staging' => FALSE,
    'move-domains-to-production' => FALSE,
    'first' => 0,
    'from' => NULL,
    'to' => NULL,
    'onesite' => '',
    'all' => FALSE,
    'full-update' => FALSE,
    'dc' => array(),
    'verbose' => FALSE,
    'procs' => 1,
    'log-dir' => '/var/log/drush',
    'log-prefix' => 'drush.' . $date,
    'nice' => FALSE,
    'dry-run' => FALSE,
    'cleanup' => FALSE,
  );
}


function usage() {
  $a = drush_gardens_args();
  $file = basename(__FILE__);
  $o = <<<EOF
    Usage: {$file} [options] --dc 'DRUSH_COMMAND' [--dc 'ANOTHER_DRUSH_COMMAND' ...]

    Runs multiple drush commands on multiple sites in a multisite drupal install.

    Examples:
    ------------------------

    {$file} --all --full-update
    Updates the DB of all sites. 
    Runs drush commands for each site:
    go-offline, move-gsite-domains, updatedb, go-online

    {$file} --first 5 --dc 'root: go-offline' --dc 'root: mgd' --dc 'updatedb -v' --dc 'always: root: go-online' --verbose
    Move domains back and update the DB of the first 5 sites with verbose output.
    Put sites offline before running the other commands, and back online after.
    We use the root: tag on hosting commands to run them as root.
    We use the always: tag to indicate that a command should run even if the ones
    before it fail.

    {$file} --from 5 --to 20 --procs 15 --log-dir /var/log/drush --dc 'updatedb' --dc 'cron'
    Updates the DB and then runs cron on each site
    Run on the 15 sites (numbers start at --from 0)
    Runs 15 threads concurrently
    Logs results to /var/log/drush

    Options:

EOF;
  foreach ($a as $opt => $default) {
    $o .= "--$opt\n";
  }
  echo $o;
}

