#!/usr/bin/env bash
# $Id$
#
# This script is a simple wrapper that will run Drush with the most appropriate
# php executable it can find. It's derived from drush/drush but omits stuff
# speficic to windows, etc, and defines a list of allowed commands.
#

# This wrapper is invoked from the task server. To limit the
# damage in case mistaken commands are sent, we define the allowed
# commands.  Otherwise, this script is the same as gardens-drush.
ALLOWED_COMMANDS="gprs domain-sync domain-config export export-s3 et-phone-home go-offline status go-online cc vset vdel cron jslib-switch-url scarecrow-assign-permission scarecrow-revoke-permission gardens-broadcasting-client-tasks-get"

# The task server always calls this script as root, but many Drupal-related
# commands shouldn't be run as root (because they could result in incorrect
# file ownership, e.g. of aggregated CSS or other generated files). The
# commands listed below are a subset of ALLOWED_COMMANDS that this script will
# run as the tangleXXX user instead.
NON_ROOT_COMMANDS="gprs et-phone-home cc vset vdel cron jslib-switch-url scarecrow-assign-permission scarecrow-revoke-permission gardens-broadcasting-client-tasks-get"

if [ -z "$1" ]; then
  echo "Allowed commands are: $ALLOWED_COMMANDS";
  exit 1;
fi

# Allow commands to be run against multiple sites using the standard Drush
# syntax "drush site1,site2,site3 command-name". Otherwise, the command must be
# the first argument.
if [[ $1 == *,* ]]; then
  if [ -z "$2" ]; then
    echo "Allowed commands are: $ALLOWED_COMMANDS";
    exit 1;
  fi
  COMMAND=$2
else
  COMMAND=$1
fi

# Validate the command.
for cmd in $ALLOWED_COMMANDS; do
  if  [ "$COMMAND" = "$cmd" ]; then
    FOUND=$cmd;
    break;
  fi
done

if [ -z "$FOUND" ]; then
  echo "$COMMAND is not an allowed command";
  echo "Allowed commands are: $ALLOWED_COMMANDS";
  exit 2;
fi

# Get the absolute path of this executable
ORIGDIR=$(pwd)
SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")

# Resolve symlinks - this is the equivalent of "readlink -f", but also works with non-standard OS X readlink.
while [ -h $SELF_PATH ]; do
    # 1) cd to directory of the symlink
    # 2) cd to the directory of where the symlink points
    # 3) Get the pwd
    # 4) Append the basename
    DIR=$(dirname -- "$SELF_PATH")
    SYM=$(readlink $SELF_PATH)
    SELF_PATH=$(cd $DIR && cd $(dirname -- "$SYM") && pwd)/$(basename -- "$SYM")
done
cd "$ORIGDIR"

# Build the path to drush.php.
SELF_DIR=$(dirname $SELF_PATH)
SCRIPT_PATH=$SELF_DIR/drush/drush.php
INCLUDE_PATH=$SELF_DIR/hosting-drush
ROOT_PATH=$SELF_DIR/docroot

# If this is a non-root command, we will run it with "sudo -u tangleXXX".
SUDO_COMMAND=""
for cmd in $NON_ROOT_COMMANDS; do
  if  [ "$COMMAND" = "$cmd" ]; then
    # Get the tangle user's name from the current directory. Staging sites
    # (e.g., tangle001_up) run under the parent site's user (e.g., tangle001).
    # By convention, we look for the last "_" as the separator here, since
    # Gardens tangle names never use "_" for anything else.
    #
    # We have PHP equivalents of this code in hosting-drush/hosting.drush.inc,
    # among other places.
    TANGLE=$(basename $SELF_DIR)
    TANGLE_USER=${TANGLE%_*}
    SUDO_COMMAND="sudo -u $TANGLE_USER"
    break;
  fi
done

# Assume dumb terminal for tasks.
export TERM=dumb

# We run with straight php, which works on most systems.
exec $SUDO_COMMAND php $SCRIPT_PATH --include=$INCLUDE_PATH --root=$ROOT_PATH -y --nocolor "$@"

